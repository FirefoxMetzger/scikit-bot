# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: ignition/msgs/time.proto, ignition/msgs/header.proto, ignition/msgs/entity.proto, ignition/msgs/vector3d.proto, ignition/msgs/quaternion.proto, ignition/msgs/pose.proto, ignition/msgs/actor.proto, ignition/msgs/actuators.proto, ignition/msgs/sensor_noise.proto, ignition/msgs/air_pressure_sensor.proto, ignition/msgs/altimeter.proto, ignition/msgs/altimeter_sensor.proto, ignition/msgs/color.proto, ignition/msgs/any.proto, ignition/msgs/atmosphere.proto, ignition/msgs/axis.proto, ignition/msgs/axis_aligned_box.proto, ignition/msgs/battery.proto, ignition/msgs/battery_state.proto, ignition/msgs/boolean.proto, ignition/msgs/boxgeom.proto, ignition/msgs/bytes.proto, ignition/msgs/camera_cmd.proto, ignition/msgs/camera_info.proto, ignition/msgs/camera_lens.proto, ignition/msgs/vector2d.proto, ignition/msgs/distortion.proto, ignition/msgs/camerasensor.proto, ignition/msgs/cessna.proto, ignition/msgs/clock.proto, ignition/msgs/cmd_vel2d.proto, ignition/msgs/cylindergeom.proto, ignition/msgs/spheregeom.proto, ignition/msgs/planegeom.proto, ignition/msgs/imagegeom.proto, ignition/msgs/image.proto, ignition/msgs/heightmapgeom.proto, ignition/msgs/meshgeom.proto, ignition/msgs/polylinegeom.proto, ignition/msgs/conegeom.proto, ignition/msgs/geometry.proto, ignition/msgs/friction.proto, ignition/msgs/surface.proto, ignition/msgs/material.proto, ignition/msgs/plugin.proto, ignition/msgs/visual.proto, ignition/msgs/collision.proto, ignition/msgs/wrench.proto, ignition/msgs/joint_wrench.proto, ignition/msgs/contact.proto, ignition/msgs/contacts.proto, ignition/msgs/contactsensor.proto, ignition/msgs/density.proto, ignition/msgs/diagnostics.proto, ignition/msgs/discovery.proto, ignition/msgs/double.proto, ignition/msgs/double_v.proto, ignition/msgs/duration.proto, ignition/msgs/empty.proto, ignition/msgs/light.proto, ignition/msgs/gps_sensor.proto, ignition/msgs/imu_sensor.proto, ignition/msgs/lidar_sensor.proto, ignition/msgs/logical_camera_sensor.proto, ignition/msgs/magnetometer_sensor.proto, ignition/msgs/sensor.proto, ignition/msgs/joint.proto, ignition/msgs/inertial.proto, ignition/msgs/projector.proto, ignition/msgs/link.proto, ignition/msgs/model.proto, ignition/msgs/entity_factory.proto, ignition/msgs/entity_factory_v.proto, ignition/msgs/float.proto, ignition/msgs/float_v.proto, ignition/msgs/fluid.proto, ignition/msgs/fluid_pressure.proto, ignition/msgs/fog.proto, ignition/msgs/version.proto, ignition/msgs/version_range.proto, ignition/msgs/versioned_name.proto, ignition/msgs/fuel_metadata.proto, ignition/msgs/gps.proto, ignition/msgs/track_visual.proto, ignition/msgs/gui_camera.proto, ignition/msgs/gui.proto, ignition/msgs/hydra.proto, ignition/msgs/imu.proto, ignition/msgs/int32.proto, ignition/msgs/int32_v.proto, ignition/msgs/int64.proto, ignition/msgs/int64_v.proto, ignition/msgs/joint_animation.proto, ignition/msgs/pid.proto, ignition/msgs/joint_cmd.proto, ignition/msgs/joint_trajectory_point.proto, ignition/msgs/joint_trajectory.proto, ignition/msgs/joy.proto, ignition/msgs/joystick.proto, ignition/msgs/laserscan.proto, ignition/msgs/link_data.proto, ignition/msgs/log_control.proto, ignition/msgs/log_playback_control.proto, ignition/msgs/log_playback_stats.proto, ignition/msgs/log_status.proto, ignition/msgs/logical_camera_image.proto, ignition/msgs/magnetometer.proto, ignition/msgs/marker.proto, ignition/msgs/marker_v.proto, ignition/msgs/model_configuration.proto, ignition/msgs/model_v.proto, ignition/msgs/occupancy_grid.proto, ignition/msgs/twist.proto, ignition/msgs/odometry.proto, ignition/msgs/pose_v.proto, ignition/msgs/stringmsg_v.proto, ignition/msgs/web_request.proto, ignition/msgs/world_stats.proto, ignition/msgs/packet.proto, ignition/msgs/param.proto, ignition/msgs/param_v.proto, ignition/msgs/stringmsg.proto, ignition/msgs/particle_emitter.proto, ignition/msgs/physics.proto, ignition/msgs/plugin_v.proto, ignition/msgs/pointcloud.proto, ignition/msgs/pointcloud_packed.proto, ignition/msgs/pose_animation.proto, ignition/msgs/pose_trajectory.proto, ignition/msgs/propagation_particle.proto, ignition/msgs/propagation_grid.proto, ignition/msgs/publish.proto, ignition/msgs/publishers.proto, ignition/msgs/raysensor.proto, ignition/msgs/request.proto, ignition/msgs/response.proto, ignition/msgs/rest_login.proto, ignition/msgs/rest_logout.proto, ignition/msgs/rest_post.proto, ignition/msgs/rest_response.proto, ignition/msgs/road.proto, ignition/msgs/sky.proto, ignition/msgs/scene.proto, ignition/msgs/sdf_generator_config.proto, ignition/msgs/selection.proto, ignition/msgs/sensor_v.proto, ignition/msgs/serialized.proto, ignition/msgs/serialized_map.proto, ignition/msgs/server_control.proto, ignition/msgs/shadows.proto, ignition/msgs/sim_event.proto, ignition/msgs/sonar.proto, ignition/msgs/spherical_coordinates.proto, ignition/msgs/statistic.proto, ignition/msgs/subscribe.proto, ignition/msgs/tactile.proto, ignition/msgs/test.proto, ignition/msgs/topic_info.proto, ignition/msgs/uint32.proto, ignition/msgs/uint32_v.proto, ignition/msgs/uint64.proto, ignition/msgs/uint64_v.proto, ignition/msgs/undo_redo.proto, ignition/msgs/world_reset.proto, ignition/msgs/world_control.proto, ignition/msgs/user_cmd.proto, ignition/msgs/user_cmd_stats.proto, ignition/msgs/video_record.proto, ignition/msgs/visual_v.proto, ignition/msgs/wind.proto, ignition/msgs/wireless_node.proto, ignition/msgs/wireless_nodes.proto, ignition/msgs/world_modify.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import Dict, List

import betterproto


class EntityType(betterproto.Enum):
    NONE = 0
    LIGHT = 1
    MODEL = 2
    LINK = 3
    VISUAL = 4
    COLLISION = 5
    SENSOR = 6
    JOINT = 7


class SensorNoiseType(betterproto.Enum):
    NONE = 0
    GAUSSIAN = 2
    GAUSSIAN_QUANTIZED = 3


class AnyValueType(betterproto.Enum):
    NONE = 0
    DOUBLE = 1
    INT32 = 2
    STRING = 3
    BOOLEAN = 4
    VECTOR3D = 5
    COLOR = 6
    POSE3D = 7
    QUATERNIOND = 8
    TIME = 9


class AtmosphereType(betterproto.Enum):
    ADIABATIC = 0


class BatteryStatePowerSupplyStatus(betterproto.Enum):
    UNKNOWN = 0
    CHARGING = 1
    DISCHARGING = 2
    NOT_CHARGING = 3
    FULL = 4


class CameraInfoDistortionDistortionModelType(betterproto.Enum):
    PLUMB_BOB = 0
    RATIONAL_POLYNOMIAL = 1
    EQUIDISTANT = 2


class PixelFormatType(betterproto.Enum):
    """
    / \brief Possible pixel formats./ This list should match
    ignition::common::Image::PixelFormatType
    """

    UNKNOWN_PIXEL_FORMAT = 0
    L_INT8 = 1
    L_INT16 = 2
    RGB_INT8 = 3
    RGBA_INT8 = 4
    BGRA_INT8 = 5
    RGB_INT16 = 6
    RGB_INT32 = 7
    BGR_INT8 = 8
    BGR_INT16 = 9
    BGR_INT32 = 10
    R_FLOAT16 = 11
    RGB_FLOAT16 = 12
    R_FLOAT32 = 13
    RGB_FLOAT32 = 14
    BAYER_RGGB8 = 15
    BAYER_BGGR8 = 16
    BAYER_GBRG8 = 17
    BAYER_GRBG8 = 18


class GeometryType(betterproto.Enum):
    BOX = 0
    CYLINDER = 1
    SPHERE = 2
    PLANE = 3
    IMAGE = 4
    HEIGHTMAP = 5
    MESH = 6
    TRIANGLE_FAN = 7
    LINE_STRIP = 8
    POLYLINE = 9
    CONE = 10
    EMPTY = 11
    ARROW = 12
    AXIS = 13


class MaterialShaderType(betterproto.Enum):
    VERTEX = 0
    PIXEL = 1
    NORMAL_MAP_OBJECT_SPACE = 2
    NORMAL_MAP_TANGENT_SPACE = 3


class MaterialPBRWorkflowType(betterproto.Enum):
    NONE = 0
    METAL = 1
    SPECULAR = 2


class VisualType(betterproto.Enum):
    ENTITY = 0
    MODEL = 1
    LINK = 2
    VISUAL = 3
    COLLISION = 4
    SENSOR = 5
    GUI = 6
    PHYSICS = 7


class DiscoveryType(betterproto.Enum):
    UNINITIALIZED = 0
    ADVERTISE = 1
    SUBSCRIBE = 2
    UNADVERTISE = 3
    HEARTBEAT = 4
    BYE = 5
    NEW_CONNECTION = 6
    END_CONNECTION = 7


class DiscoveryPublisherScope(betterproto.Enum):
    PROCESS = 0
    HOST = 1
    ALL = 2


class LightLightType(betterproto.Enum):
    POINT = 0
    SPOT = 1
    DIRECTIONAL = 2


class JointType(betterproto.Enum):
    REVOLUTE = 0
    REVOLUTE2 = 1
    PRISMATIC = 2
    UNIVERSAL = 3
    BALL = 4
    SCREW = 5
    GEARBOX = 6
    FIXED = 7


class FogFogType(betterproto.Enum):
    NONE = 0
    LINEAR = 1
    EXPONENTIAL = 2
    EXPONENTIAL2 = 3


class LogStatusLogFileUnits(betterproto.Enum):
    BYTES = 0
    K_BYTES = 1
    M_BYTES = 2
    G_BYTES = 3


class MarkerType(betterproto.Enum):
    NONE = 0
    BOX = 1
    CYLINDER = 2
    LINE_LIST = 4
    LINE_STRIP = 3
    POINTS = 5
    SPHERE = 6
    TEXT = 7
    TRIANGLE_FAN = 8
    TRIANGLE_LIST = 9
    TRIANGLE_STRIP = 10
    CONE = 11
    ARROW = 12
    AXIS = 13


class MarkerVisibility(betterproto.Enum):
    GUI = 0
    ALL = 1


class MarkerAction(betterproto.Enum):
    ADD_MODIFY = 0
    DELETE_MARKER = 1
    DELETE_ALL = 2


class ParticleEmitterEmitterType(betterproto.Enum):
    POINT = 0
    BOX = 1
    CYLINDER = 2
    ELLIPSOID = 3


class PhysicsType(betterproto.Enum):
    ODE = 0
    BULLET = 1
    SIMBODY = 2
    DART = 3


class PointCloudPackedFieldDataType(betterproto.Enum):
    INT8 = 0
    UINT8 = 1
    INT16 = 2
    UINT16 = 3
    INT32 = 4
    UINT32 = 5
    FLOAT32 = 6
    FLOAT64 = 7


class RestResponseType(betterproto.Enum):
    SUCCESS = 0
    ERR = 1
    LOGIN = 2
    LOGOUT = 3


class ShadowsShadowType(betterproto.Enum):
    STENCIL_ADDITIVE = 0
    STENCIL_MODULATIVE = 1
    TEXTURE_ADDITIVE = 2
    TEXTURE_MODULATIVE = 3


class SphericalCoordinatesSurfaceModel(betterproto.Enum):
    EARTH_WGS84 = 0


class StatisticDataType(betterproto.Enum):
    UNINITIALIZED = 0
    AVERAGE = 1
    MINIMUM = 2
    MAXIMUM = 3
    VARIANCE = 4
    STDDEV = 5
    SAMPLE_COUNT = 6
    ROOT_MEAN_SQUARE = 7
    MAX_ABS_VALUE = 8


class UserCmdType(betterproto.Enum):
    MOVING = 0
    WORLD_CONTROL = 1
    WRENCH = 2
    SCALING = 3


@dataclass
class Time(betterproto.Message):
    # / \brief Seconds
    sec: int = betterproto.int64_field(1)
    # / \brief Nanoseconds
    nsec: int = betterproto.int32_field(2)


@dataclass
class Header(betterproto.Message):
    stamp: "Time" = betterproto.message_field(1)
    data: List["HeaderMap"] = betterproto.message_field(2)


@dataclass
class HeaderMap(betterproto.Message):
    key: str = betterproto.string_field(1)
    value: List[str] = betterproto.string_field(2)


@dataclass
class Entity(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Entity unique identifier accross all types. Defaults to null/
    # entity (0).
    id: int = betterproto.uint64_field(2)
    # / \brief Entity name, which is not guaranteed to be unique.
    name: str = betterproto.string_field(3)
    # / \brief Entity type.
    type: "EntityType" = betterproto.enum_field(4)


@dataclass
class Vector3d(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    x: float = betterproto.double_field(2)
    y: float = betterproto.double_field(3)
    z: float = betterproto.double_field(4)


@dataclass
class Quaternion(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    x: float = betterproto.double_field(2)
    y: float = betterproto.double_field(3)
    z: float = betterproto.double_field(4)
    w: float = betterproto.double_field(5)


@dataclass
class Pose(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    name: str = betterproto.string_field(2)
    id: int = betterproto.uint32_field(3)
    position: "Vector3d" = betterproto.message_field(4)
    orientation: "Quaternion" = betterproto.message_field(5)


@dataclass
class Actor(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief A unique name for the actor
    entity: "Entity" = betterproto.message_field(2)
    # / \brief Pose of the actor
    pose: "Pose" = betterproto.message_field(3)
    # / \brief Skin file which defines a visual / and the underlying skeleton
    # which moves it
    skin_filename: str = betterproto.string_field(4)
    # / \brief Scale the skin's size
    skin_scale: float = betterproto.float_field(5)
    # / \brief Animations for the skeleton in the skin
    animations: List["ActorAnimation"] = betterproto.message_field(6)
    # / \brief Set this to true for the script to be repeated in a loop
    script_loop: bool = betterproto.bool_field(7)
    # / \brief Time (in secs) to wait before starting the script
    script_delay_start: float = betterproto.float_field(8)
    # / \brief Set to true if the animation should start / as soon as the
    # simulation starts playing
    script_auto_start: bool = betterproto.bool_field(9)
    # / \brief A series of keyframes to be followed
    trajectories: List["ActorTrajectory"] = betterproto.message_field(10)
    # / \brief Unique id of actor's parent
    parent: "Entity" = betterproto.message_field(11)


@dataclass
class ActorAnimation(betterproto.Message):
    # / \brief Unique name for animation
    name: str = betterproto.string_field(1)
    # / \brief Path to animation file. Accepted formats: COLLADA, BVH
    filename: str = betterproto.string_field(2)
    # / \brief Scale for the animation skeleton
    scale: float = betterproto.float_field(3)
    # / \brief Set to true so the animation is interpolated on X
    interpolate_x: bool = betterproto.bool_field(4)


@dataclass
class ActorWaypoint(betterproto.Message):
    # / \brief Time in seconds, counted from the beginning of the script
    time: float = betterproto.float_field(1)
    # / \brief Pose to be reached at the given time
    pose: "Pose" = betterproto.message_field(2)


@dataclass
class ActorTrajectory(betterproto.Message):
    # / \brief Unique id for a trajectory
    id: int = betterproto.uint32_field(1)
    # / \brief Type of an animation
    type: str = betterproto.string_field(2)
    # / \brief Tension of the trajectory spline
    tension: float = betterproto.float_field(3)
    # / \brief Points in the trajectory
    waypoints: List["ActorWaypoint"] = betterproto.message_field(4)


@dataclass
class Actuators(betterproto.Message):
    """/ \brief Actuator commands."""

    # Optional header data.
    header: "Header" = betterproto.message_field(1)
    # / \brief Position of the actuators in [rad] for angular actuators/ and [m]
    # for linear actuators.
    position: List[float] = betterproto.double_field(2)
    # / \brief Velocities of the actuators in [rad/s] for angular actuators/ and
    # [m/s] for linear actuators.
    velocity: List[float] = betterproto.double_field(3)
    # / \brief Everything that does not fit the above,/ normalized between [-1
    # ... 1].
    normalized: List[float] = betterproto.double_field(4)


@dataclass
class SensorNoise(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief The type of noise
    type: "SensorNoiseType" = betterproto.enum_field(2)
    # / \brief Noise mean/ Used by GAUSSIAN, and GAUSSIAN_QUANTIZED
    mean: float = betterproto.double_field(3)
    # / \brief Noise standard deviation/ Used by GAUSSIAN, and GAUSSIAN_QUANTIZED
    stddev: float = betterproto.double_field(4)
    # / \brief Noise mean bias/ Used by GAUSSIAN, and GAUSSIAN_QUANTIZED
    bias_mean: float = betterproto.double_field(5)
    # / \brief Noise standard deviation bias/ Used by GAUSSIAN, and
    # GAUSSIAN_QUANTIZED
    bias_stddev: float = betterproto.double_field(6)
    # / \brief Noise  precision./ Used by GAUSSIAN_QUANTIZED
    precision: float = betterproto.double_field(7)
    # / \brief For type "gaussian*", the standard deviation of the noise used to/
    # drive a process to model slow variations in a sensor bias.
    dynamic_bias_stddev: float = betterproto.double_field(8)
    # / \brief For type "gaussian*", the correlation time in seconds of the/
    # noise used to drive a process to model slow variations in a sensor bias./ A
    # typical value, when used, would be on the order of/ 3600 seconds (1 hour).
    dynamic_bias_correlation_time: float = betterproto.double_field(9)


@dataclass
class AirPressureSensor(betterproto.Message):
    """/ \brief Message that describes an air pressure sensor."""

    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Reference altitude in meters. This value can be used by a sensor/
    # implementation to augment the altitude of the sensor. For example, if/ you
    # are using simulation, instead of creating a 1000 m mountain model on/ which
    # to place your sensor, you could instead set this value to 1000 and/ place
    # your model on a ground plane with a Z height of zero.
    reference_altitude: float = betterproto.double_field(2)
    # / \brief Sensor pressure noise.
    pressure_noise: "SensorNoise" = betterproto.message_field(3)


@dataclass
class Altimeter(betterproto.Message):
    """/ \brief Altimeter sensor data"""

    # Other Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Vertical position data, in meters.
    vertical_position: float = betterproto.double_field(2)
    # / \brief Vertical velocity data, in meters/second.
    vertical_velocity: float = betterproto.double_field(3)
    # / \brief Vertical reference.
    vertical_reference: float = betterproto.double_field(4)


@dataclass
class AltimeterSensor(betterproto.Message):
    """/ \brief Message that describes an altimeter sensor."""

    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Noise parameters for the vertical position.
    vertical_position_noise: "SensorNoise" = betterproto.message_field(2)
    # / \brief Noise parameters for the vertical velocity.
    vertical_velocity_noise: "SensorNoise" = betterproto.message_field(3)


@dataclass
class Color(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    r: float = betterproto.float_field(2)
    g: float = betterproto.float_field(3)
    b: float = betterproto.float_field(4)
    a: float = betterproto.float_field(5)


@dataclass
class Any(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Type of value that is contained in this message.
    type: "AnyValueType" = betterproto.enum_field(2)
    # / \brief A double value
    double_value: float = betterproto.double_field(3, group="value")
    # / \brief An int32 value
    int_value: int = betterproto.int32_field(4, group="value")
    # / \brief A string value
    string_value: str = betterproto.string_field(5, group="value")
    # / \brief A boolean value
    bool_value: bool = betterproto.bool_field(6, group="value")
    # / \brief A Vector3d value
    vector3d_value: "Vector3d" = betterproto.message_field(7, group="value")
    # / \brief A Color value
    color_value: "Color" = betterproto.message_field(8, group="value")
    # / \brief A Pose value
    pose3d_value: "Pose" = betterproto.message_field(9, group="value")
    # / \brief A Quaternion value
    quaternion_value: "Quaternion" = betterproto.message_field(10, group="value")
    # / \brief A Time value
    time_value: "Time" = betterproto.message_field(11, group="value")


@dataclass
class Atmosphere(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Type of the atmosphere model.
    type: "AtmosphereType" = betterproto.enum_field(2)
    # / \brief Temperature at sea level in kelvins.
    temperature: float = betterproto.double_field(3)
    # / \brief Pressure at sea level in pascals.
    pressure: float = betterproto.double_field(4)
    # / \brief Mass density of the air at sea level in kg/m^3.
    mass_density: float = betterproto.double_field(5)
    # / \brief Enable atmosphere model
    enable_atmosphere: bool = betterproto.bool_field(6)


@dataclass
class Axis(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief The x,y,z components of the axis unit vector.
    xyz: "Vector3d" = betterproto.message_field(2)
    # / \brief The lower joint axis limit (radians for revolute joints,/ meters
    # for prismatic joints). Not valid if the joint that uses this/ axis is
    # continuous.
    limit_lower: float = betterproto.double_field(3)
    # / \brief The upper joint axis limit (radians for revolute joints,/ meters
    # for prismatic joints). Not valid if the joint that uses this/ axis is
    # continuous.
    limit_upper: float = betterproto.double_field(4)
    # / \brief Value for enforcing the maximum joint effort applied./ Limit is
    # not enforced if value is negative.
    limit_effort: float = betterproto.double_field(5)
    # / \brief Value for enforcing the maximum joint velocity.
    limit_velocity: float = betterproto.double_field(6)
    # / \brief The physical velocity dependent viscous damping coefficient/ of
    # the joint axis.
    damping: float = betterproto.double_field(7)
    # / \brief The physical static friction value of the joint.
    friction: float = betterproto.double_field(8)
    # / \brief True if the coordinates are expressed in the parent model frame./
    # \deprecated Use `xyz_expressed_in` instead.
    use_parent_model_frame: bool = betterproto.bool_field(9)
    # / \brief Position of the joint. For angular joints, such as revolute/
    # joints, the units are radians. For linear joints, such as prismatic/
    # joints, the units are meters.
    position: float = betterproto.double_field(10)
    # / \brief Velocity of the joint in SI units (meter/second).
    velocity: float = betterproto.double_field(11)
    # / \brief Force applied to the joint in SI units (Newton).
    force: float = betterproto.double_field(12)
    # / \brief Acceleration of the joint is SI units (meter/second^2).
    acceleration: float = betterproto.double_field(13)
    # / \brief Set the name of the coordinate frame in which this joint axis's/
    # unit vector is expressed. An empty value implies the parent (joint)/ frame.
    xyz_expressed_in: str = betterproto.string_field(14)


@dataclass
class AxisAlignedBox(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Minimum corner of the axis aligned bound box in the global frame.
    min_corner: "Vector3d" = betterproto.message_field(2)
    # / \brief Maximum corner of the axis aligned bound box in the global frame.
    max_corner: "Vector3d" = betterproto.message_field(3)


@dataclass
class Battery(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Name of the battery
    name: str = betterproto.string_field(2)
    # / \brief Real voltage in volts.
    voltage: float = betterproto.double_field(3)


@dataclass
class BatteryState(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Voltage in Volts
    voltage: float = betterproto.double_field(2)
    # / \brief Current draw in Ampere
    current: float = betterproto.double_field(3)
    # / \brief Amount of charge in the battery in Ah
    charge: float = betterproto.double_field(4)
    # / \brief Capacity in Ah
    capacity: float = betterproto.double_field(5)
    # / \brief Percentage of charge left
    percentage: float = betterproto.double_field(6)
    # / \brief The charging status
    power_supply_status: "BatteryStatePowerSupplyStatus" = betterproto.enum_field(7)


@dataclass
class Boolean(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Boolean data
    data: bool = betterproto.bool_field(2)


@dataclass
class BoxGeom(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    size: "Vector3d" = betterproto.message_field(2)


@dataclass
class Bytes(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Bytes data
    data: bytes = betterproto.bytes_field(2)


@dataclass
class CameraCmd(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    follow_model: str = betterproto.string_field(2)


@dataclass
class CameraInfo(betterproto.Message):
    """
    / \brief Meta information about a camera and the images produced by the/
    camera. This data is typically published alongside a camera image stream/
    on a topic called "camera_info".// Format of this message as heavily
    borrowed from:/
    http://docs.ros.org/melodic/api/sensor_msgs/html/msg/CameraInfo.html
    """

    # / \brief Header data. The header timestamp is the time of image/
    # acquisition. The header data map should have a 'frame_id' key with a/ value
    # that is the camera coordinate frame ID.
    header: "Header" = betterproto.message_field(1)
    # / \brief Width of the image produced by a camera in pixels.
    width: int = betterproto.uint32_field(2)
    # / \brief Height of the image produced by a camera in pixels.
    height: int = betterproto.uint32_field(3)
    # / \brief Distortion information for the camera images.
    distortion: "CameraInfoDistortion" = betterproto.message_field(4)
    # / \brief Camera intrinsics.
    intrinsics: "CameraInfoIntrinsics" = betterproto.message_field(5)
    # / \brief Camera projection information.
    projection: "CameraInfoProjection" = betterproto.message_field(6)
    # / \brief Rectification matrix (stereo cameras only)./ A rotation matrix
    # aligning the camera coordinate system to the ideal/ stereo image plane so
    # that epipolar lines in both stereo images are/ parallel./ This field should
    # be treated as a 3x3 row-major matrix.
    rectification_matrix: List[float] = betterproto.double_field(7)


@dataclass
class CameraInfoDistortion(betterproto.Message):
    """/ The distortion model used by the camera."""

    # / \brief The distortion model used.
    model: "CameraInfoDistortionDistortionModelType" = betterproto.enum_field(1)
    # / \brief Distortion coefficients. The meaning of the coefficients changes/
    # according to the distortion model:// PLUMP_BOB: 5 parameters, in this
    # order:/   * k1: radial distortion coefficient k1/   * k2: radial distortion
    # coefficient k2/   * t1: tangential distortion coefficient t1/   * t2:
    # tangential distortion coefficient t2/   * k3: radial distortion coefficient
    # k3// RATIONAL_POLYNOMIAL: 8 parameters// EQUIDISTANT: 4 parameters,
    # described in this paper:/
    # http://www.ee.oulu.fi/~jkannala/publications/tpami2006.pdf
    k: List[float] = betterproto.double_field(2)


@dataclass
class CameraInfoIntrinsics(betterproto.Message):
    """
    / \brief Intrinsic camera matrix for the raw (distorted) images can be/
    generated using the fx, fy, cx, and cy parameters contained in this/
    message. For example the intrinsic camera matrix K would be:/     [fx  s
    cx]/ K = [ 0 fy cy]/     [ 0  0  1]/ Projects 3D points in the camera
    coordinate frame to 2D pixel/ coordinates using the focal lengths (fx, fy)
    and principal point/ (cx, cy).
    """

    # / \brief 3x3 row-major matrix
    k: List[float] = betterproto.double_field(1)


@dataclass
class CameraInfoProjection(betterproto.Message):
    """
    / \brief The projection/camera matrix can be generated using the values in/
    this message. For example, the projection matrix P would be://     [fx   s
    cx tx]/ P = [ 0  fy cy ty]/     [ 0   0  1  0]// Where:/ * fx is the X
    Focal length/ * fy is the Y Focal length/ * cx is the X principal point/ *
    cy is the Y principal point/ * tx is the X position of the second camera in
    this camera's frame./ * ty is the Y position of the second camera in this
    camera's frame./ * s is the axis skew.// By convention, this matrix
    specifies the intrinsic (camera) matrix/  of the processed (rectified)
    image. That is, the left 3x3 portion/  is the normal camera intrinsic
    matrix for the rectified image./ It projects 3D points in the camera
    coordinate frame to 2D pixel/  coordinates using the focal lengths (fx, fy)
    and principal point/  (cx, cy) - these may differ from the values in the
    Intrinsics message./ For monocular cameras, tx = ty = 0. Normally,
    monocular cameras will/  also have R = the identity and P[1:3,1:3] = K./
    For a stereo pair, tx  and ty are related to the/  position of the optical
    center of the second camera in the first/  camera's frame. We assume both
    cameras are in the same/  stereo image plane. The first camera always has
    tx = ty = 0. For/  the right (second) camera of a horizontal stereo pair,
    ty = 0 and/  tx = -fx * B, where B is the baseline between the cameras./
    Given a 3D point [X Y Z]', the projection (x, y) of the point onto/  the
    rectified image is given by:/  [u v w]' = P * [X Y Z 1]'/         x = u /
    w/         y = v / w/  This holds for both images of a stereo pair.
    """

    # / \brief 3x4 row-major matrix
    p: List[float] = betterproto.double_field(1)


@dataclass
class CameraLens(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Type of projection of the lens/        possible values are
    # "gnomonical", "stereographic", "equidistant",/        "equisolid_angle",
    # "stereographic", "custom"./        If you set this value to "custom" you
    # need to specify at least one/        of the `c1`, `c2`, `c3`, `f` or `fun`.
    type: str = betterproto.string_field(2)
    # / \brief Linear image scaling factor
    c1: float = betterproto.double_field(3)
    # / \brief Angle scaling factor
    c2: float = betterproto.double_field(4)
    # / \brief Angle offset factor
    c3: float = betterproto.double_field(5)
    # / \brief Linear scaling factor, unlike `c1`, will be adjusted to match
    # hfov/        if scale_to_fov is set to `true`.
    f: float = betterproto.double_field(6)
    # / \brief Angle modification function         possible values are "tan",
    # "sin" and "id".
    fun: str = betterproto.string_field(7)
    # / \brief Scale image to fit horizontal FOV
    scale_to_hfov: bool = betterproto.bool_field(8)
    # / \brief Everything outside of this angle will be hidden,/        the angle
    # is counted from camera's X (forward) axis.
    cutoff_angle: float = betterproto.double_field(9)
    # / \brief Horizontal field of view in radians.
    hfov: float = betterproto.double_field(10)
    # / \brief Size of cube map texture,/        used to store intermediate
    # rendering result.
    env_texture_size: int = betterproto.int32_field(11)


@dataclass
class Vector2d(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    x: float = betterproto.double_field(2)
    y: float = betterproto.double_field(3)


@dataclass
class Distortion(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    center: "Vector2d" = betterproto.message_field(2)
    k1: float = betterproto.double_field(3)
    k2: float = betterproto.double_field(4)
    k3: float = betterproto.double_field(5)
    p1: float = betterproto.double_field(6)
    p2: float = betterproto.double_field(7)


@dataclass
class CameraSensor(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    horizontal_fov: float = betterproto.double_field(2)
    image_size: "Vector2d" = betterproto.message_field(3)
    image_format: str = betterproto.string_field(4)
    near_clip: float = betterproto.double_field(5)
    far_clip: float = betterproto.double_field(6)
    save_enabled: bool = betterproto.bool_field(7)
    save_path: str = betterproto.string_field(8)
    distortion: "Distortion" = betterproto.message_field(9)


@dataclass
class Cessna(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Current RPM of the propeller.
    propeller_speed: float = betterproto.float_field(2)
    # / \brief Current left aileron angle in rads.
    left_aileron: float = betterproto.float_field(3)
    # / \brief Current left flap angle in rads.
    left_flap: float = betterproto.float_field(4)
    # / \brief Current right aileron angle in rads.
    right_aileron: float = betterproto.float_field(5)
    # / \brief Current right flap angle in rads.
    right_flap: float = betterproto.float_field(6)
    # / \brief Current elevators angle in rads.
    elevators: float = betterproto.float_field(7)
    # / \brief Current ruddle angle in rads.
    rudder: float = betterproto.float_field(8)
    # / \brief Target RPM of the propeller.
    cmd_propeller_speed: float = betterproto.float_field(9)
    # / \brief Target left aileron angle in rads.
    cmd_left_aileron: float = betterproto.float_field(10)
    # / \brief Target left flap angle in rads.
    cmd_left_flap: float = betterproto.float_field(11)
    # / \brief Target right aileron angle in rads.
    cmd_right_aileron: float = betterproto.float_field(12)
    # / \brief Target right flap angle in rads.
    cmd_right_flap: float = betterproto.float_field(13)
    # / \brief Target elevators angle in rads.
    cmd_elevators: float = betterproto.float_field(14)
    # / \brief Target ruddle angle in rads.
    cmd_rudder: float = betterproto.float_field(15)


@dataclass
class Clock(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    system: "Time" = betterproto.message_field(2)
    real: "Time" = betterproto.message_field(3)
    sim: "Time" = betterproto.message_field(4)


@dataclass
class CmdVel2D(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    velocity: float = betterproto.double_field(2)
    theta: float = betterproto.double_field(3)


@dataclass
class CylinderGeom(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    radius: float = betterproto.double_field(2)
    length: float = betterproto.double_field(3)


@dataclass
class SphereGeom(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Radius of the sphere.
    radius: float = betterproto.double_field(2)


@dataclass
class PlaneGeom(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    normal: "Vector3d" = betterproto.message_field(2)
    size: "Vector2d" = betterproto.message_field(3)
    d: float = betterproto.double_field(4)


@dataclass
class ImageGeom(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    uri: str = betterproto.string_field(2)
    scale: float = betterproto.double_field(3)
    threshold: int = betterproto.int32_field(4)
    height: float = betterproto.double_field(5)
    granularity: int = betterproto.int32_field(6)


@dataclass
class Image(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Image wisth (number of columns)
    width: int = betterproto.uint32_field(2)
    # / \brief Image height (number of rows)
    height: int = betterproto.uint32_field(3)
    # / \brief Full row length in bytes
    step: int = betterproto.uint32_field(4)
    # / \brief Actual data, size if (step * rows)
    data: bytes = betterproto.bytes_field(5)
    # / \brief Pixel format type.
    pixel_format_type: "PixelFormatType" = betterproto.enum_field(6)


@dataclass
class HeightmapGeom(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    image: "Image" = betterproto.message_field(2)
    size: "Vector3d" = betterproto.message_field(3)
    origin: "Vector3d" = betterproto.message_field(4)
    heights: List[float] = betterproto.float_field(5)
    width: int = betterproto.int32_field(6)
    height: int = betterproto.int32_field(7)
    texture: List["HeightmapGeomTexture"] = betterproto.message_field(8)
    blend: List["HeightmapGeomBlend"] = betterproto.message_field(9)
    use_terrain_paging: bool = betterproto.bool_field(10)
    # The image filename
    filename: str = betterproto.string_field(11)
    # Sample level
    sampling: int = betterproto.uint32_field(12)


@dataclass
class HeightmapGeomTexture(betterproto.Message):
    diffuse: str = betterproto.string_field(1)
    normal: str = betterproto.string_field(2)
    size: float = betterproto.double_field(3)


@dataclass
class HeightmapGeomBlend(betterproto.Message):
    min_height: float = betterproto.double_field(1)
    fade_dist: float = betterproto.double_field(2)


@dataclass
class MeshGeom(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    filename: str = betterproto.string_field(2)
    scale: "Vector3d" = betterproto.message_field(3)
    submesh: str = betterproto.string_field(4)
    center_submesh: bool = betterproto.bool_field(5)


@dataclass
class Polyline(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    height: float = betterproto.double_field(2)
    point: List["Vector2d"] = betterproto.message_field(3)


@dataclass
class ConeGeom(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief The base radius of cone in meters
    radius: float = betterproto.double_field(2)
    # / \brief The distance in meters from the base to the apex of the cone
    length: float = betterproto.double_field(3)


@dataclass
class Geometry(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    type: "GeometryType" = betterproto.enum_field(2)
    box: "BoxGeom" = betterproto.message_field(3)
    cylinder: "CylinderGeom" = betterproto.message_field(4)
    plane: "PlaneGeom" = betterproto.message_field(5)
    sphere: "SphereGeom" = betterproto.message_field(6)
    image: "ImageGeom" = betterproto.message_field(7)
    heightmap: "HeightmapGeom" = betterproto.message_field(8)
    mesh: "MeshGeom" = betterproto.message_field(9)
    cone: "ConeGeom" = betterproto.message_field(10)
    points: List["Vector3d"] = betterproto.message_field(11)
    polyline: List["Polyline"] = betterproto.message_field(12)


@dataclass
class Friction(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Coefficient of friction in the range of [0..1].
    mu: float = betterproto.double_field(2)
    # / \brief Second coefficient of friction in the range of [0..1].
    mu2: float = betterproto.double_field(3)
    # / \brief Direction of mu1 in the collision local reference frame.
    fdir1: "Vector3d" = betterproto.message_field(4)
    # / \brief Force dependent slip direction 1 in collision local frame,
    # between/ the range of [0..1].
    slip1: float = betterproto.double_field(5)
    # / \brief Force dependent slip direction 2 in collision local frame,
    # between/ the range of [0..1].
    slip2: float = betterproto.double_field(6)
    # / \brief Torsional friction.
    torsional: "FrictionTorsional" = betterproto.message_field(7)


@dataclass
class FrictionTorsional(betterproto.Message):
    # / \brief Torsional coefficient of friction in the range of [0..1].
    coefficient: float = betterproto.double_field(1)
    # / \brief By default, torsional friction is calculated using the/
    # "patch_radius", which is sqrt(R*d), where "R" is the radius of the/
    # collision at the contact point (surface_radius) and "d" is the contact/
    # depth. If this flag is set to false, surface_radius and contact depth/ will
    # be used instead of patch radius.
    use_patch_radius: bool = betterproto.bool_field(2)
    # / \brief Radius of contact patch surface, used for torsional friction.
    patch_radius: float = betterproto.double_field(3)
    # / \brief Surface radius on the point of contact, used for torsional/
    # friction.
    surface_radius: float = betterproto.double_field(4)
    # / \brief Torsional friction information exclusive to ODE physics engine.
    ode: "FrictionTorsionalODE" = betterproto.message_field(5)


@dataclass
class FrictionTorsionalODE(betterproto.Message):
    # / \brief Force dependent slip for torsional friction, between the range/ of
    # [0..1].
    slip: float = betterproto.double_field(1)


@dataclass
class Surface(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    friction: "Friction" = betterproto.message_field(2)
    restitution_coefficient: float = betterproto.double_field(3)
    bounce_threshold: float = betterproto.double_field(4)
    soft_cfm: float = betterproto.double_field(5)
    soft_erp: float = betterproto.double_field(6)
    kp: float = betterproto.double_field(7)
    kd: float = betterproto.double_field(8)
    max_vel: float = betterproto.double_field(9)
    min_depth: float = betterproto.double_field(10)
    collide_without_contact: bool = betterproto.bool_field(11)
    collide_without_contact_bitmask: int = betterproto.uint32_field(12)
    collide_bitmask: int = betterproto.uint32_field(13)
    elastic_modulus: float = betterproto.double_field(14)


@dataclass
class Material(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    script: "MaterialScript" = betterproto.message_field(2)
    shader_type: "MaterialShaderType" = betterproto.enum_field(3)
    normal_map: str = betterproto.string_field(4)
    ambient: "Color" = betterproto.message_field(5)
    diffuse: "Color" = betterproto.message_field(6)
    specular: "Color" = betterproto.message_field(7)
    emissive: "Color" = betterproto.message_field(8)
    lighting: bool = betterproto.bool_field(9)
    # / \brief Physically Based Rendering (PBR) material properties
    pbr: "MaterialPBR" = betterproto.message_field(10)


@dataclass
class MaterialScript(betterproto.Message):
    uri: List[str] = betterproto.string_field(1)
    name: str = betterproto.string_field(2)


@dataclass
class MaterialPBR(betterproto.Message):
    """/ \brief Physically Based Rendering (PBR) material properties."""

    # / \brief Type of PBR workflow
    type: "MaterialPBRWorkflowType" = betterproto.enum_field(1)
    # / \brief Filename of the albedo map
    albedo_map: str = betterproto.string_field(2)
    # / \brief Filename of the normal map
    normal_map: str = betterproto.string_field(3)
    # / \brief Metalness value (metal workflow)
    metalness: float = betterproto.double_field(4)
    # / \brief Filename of the metalness map (metal workflow)
    metalness_map: str = betterproto.string_field(5)
    # / \brief Roughness value (metal workflow)
    roughness: float = betterproto.double_field(6)
    # / \brief Filename of the roughness map (metal workflow)
    roughness_map: str = betterproto.string_field(7)
    # / \brief Glossiness value (specular workflow)
    glossiness: float = betterproto.double_field(8)
    # / \brief Filename of the glossiness map (specular workflow)
    glossiness_map: str = betterproto.string_field(9)
    # / \brief Filename of the specular map (specular workflow)
    specular_map: str = betterproto.string_field(10)
    # / \brief Filename of the environment map
    environment_map: str = betterproto.string_field(11)
    # / \brief Filename of the ambient occlusion map
    ambient_occlusion_map: str = betterproto.string_field(12)
    # / \brief Filename of the emissive map
    emissive_map: str = betterproto.string_field(13)


@dataclass
class Plugin(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    name: str = betterproto.string_field(2)
    filename: str = betterproto.string_field(3)
    innerxml: str = betterproto.string_field(4)


@dataclass
class Visual(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    name: str = betterproto.string_field(2)
    id: int = betterproto.uint32_field(3)
    parent_name: str = betterproto.string_field(4)
    parent_id: int = betterproto.uint32_field(5)
    cast_shadows: bool = betterproto.bool_field(6)
    transparency: float = betterproto.double_field(7)
    laser_retro: float = betterproto.double_field(8)
    pose: "Pose" = betterproto.message_field(9)
    geometry: "Geometry" = betterproto.message_field(10)
    material: "Material" = betterproto.message_field(11)
    visible: bool = betterproto.bool_field(12)
    delete_me: bool = betterproto.bool_field(13)
    is_static: bool = betterproto.bool_field(14)
    plugin: List["Plugin"] = betterproto.message_field(15)
    scale: "Vector3d" = betterproto.message_field(16)
    # / \brief Option meta information associated with this visual.
    meta: "VisualMeta" = betterproto.message_field(17)
    # / \brief Type of visual.
    type: "VisualType" = betterproto.enum_field(18)


@dataclass
class VisualMeta(betterproto.Message):
    """
    / \brief Optional meta information for the visual. The information/
    contained within this element should be used to provide additional/
    feedback to an end user.
    """

    # / \brief The layer in which this visual is displayed. The layer number/ is
    # useful for programs, such as Gazebo, that put visuals in different/ layers
    # for enhanced visualization.
    layer: int = betterproto.int32_field(1)


@dataclass
class Collision(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    id: int = betterproto.uint32_field(2)
    name: str = betterproto.string_field(3)
    laser_retro: float = betterproto.double_field(4)
    max_contacts: float = betterproto.double_field(5)
    pose: "Pose" = betterproto.message_field(6)
    geometry: "Geometry" = betterproto.message_field(7)
    surface: "Surface" = betterproto.message_field(8)
    visual: List["Visual"] = betterproto.message_field(9)


@dataclass
class Wrench(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    force: "Vector3d" = betterproto.message_field(2)
    torque: "Vector3d" = betterproto.message_field(3)
    force_offset: "Vector3d" = betterproto.message_field(4)


@dataclass
class JointWrench(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    body_1_name: str = betterproto.string_field(2)
    body_1_id: int = betterproto.uint32_field(3)
    body_2_name: str = betterproto.string_field(4)
    body_2_id: int = betterproto.uint32_field(5)
    body_1_wrench: "Wrench" = betterproto.message_field(6)
    body_2_wrench: "Wrench" = betterproto.message_field(7)


@dataclass
class Contact(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    collision1: "Entity" = betterproto.message_field(2)
    collision2: "Entity" = betterproto.message_field(3)
    position: List["Vector3d"] = betterproto.message_field(4)
    normal: List["Vector3d"] = betterproto.message_field(5)
    depth: List[float] = betterproto.double_field(6)
    wrench: List["JointWrench"] = betterproto.message_field(7)
    world: "Entity" = betterproto.message_field(8)


@dataclass
class Contacts(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    contact: List["Contact"] = betterproto.message_field(2)


@dataclass
class ContactSensor(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    collision_name: str = betterproto.string_field(2)


@dataclass
class Density(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    density: float = betterproto.double_field(2)


@dataclass
class Diagnostics(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    time: List["DiagnosticsDiagTime"] = betterproto.message_field(2)
    real_time: "Time" = betterproto.message_field(3)
    sim_time: "Time" = betterproto.message_field(4)
    real_time_factor: float = betterproto.double_field(5)


@dataclass
class DiagnosticsDiagTime(betterproto.Message):
    name: str = betterproto.string_field(1)
    elapsed: "Time" = betterproto.message_field(2)
    wall: "Time" = betterproto.message_field(3)


@dataclass
class Discovery(betterproto.Message):
    # / \brief Optional header data.
    header: "Header" = betterproto.message_field(1)
    # / \brief Version of the discovery protocol.
    version: int = betterproto.uint32_field(2)
    # / \brief Process UUID.
    process_uuid: str = betterproto.string_field(3)
    # / \brief The type of this message.
    type: "DiscoveryType" = betterproto.enum_field(4)
    # / \brief Optional flags.
    flags: "DiscoveryFlags" = betterproto.message_field(5)
    # / \brief Subscriber information.
    sub: "DiscoverySubscriber" = betterproto.message_field(6, group="disc_contents")
    # / \brief Publisher information.
    pub: "DiscoveryPublisher" = betterproto.message_field(7, group="disc_contents")


@dataclass
class DiscoveryFlags(betterproto.Message):
    """/ \brief Discovery flags."""

    # / \brief Flag set when a discovery message is relayed.
    relay: bool = betterproto.bool_field(1)
    # / \brief Flag set when we want to avoid to relay a discovery message./ This
    # is used to avoid loops.
    no_relay: bool = betterproto.bool_field(2)


@dataclass
class DiscoverySubscriber(betterproto.Message):
    """/ \brief Information about a subscriber."""

    topic: str = betterproto.string_field(1)


@dataclass
class DiscoveryPublisher(betterproto.Message):
    """/ \brief Information about a publisher."""

    # / \brief Topic name.
    topic: str = betterproto.string_field(1)
    # / \brief ZeroMQ address of the publisher.
    address: str = betterproto.string_field(2)
    # / \brief Process UUID of the publisher.
    process_uuid: str = betterproto.string_field(3)
    # / \brief Node UUID of the publisher.
    node_uuid: str = betterproto.string_field(4)
    # / \brief The scope of this publisher.
    scope: "DiscoveryPublisherScope" = betterproto.enum_field(5)
    # / \brief Message publisher.
    msg_pub: "DiscoveryPublisherMessagePublisher" = betterproto.message_field(
        6, group="pub_type"
    )
    # / \brief Service provider.
    srv_pub: "DiscoveryPublisherServicePublisher" = betterproto.message_field(
        7, group="pub_type"
    )


@dataclass
class DiscoveryPublisherMessagePublisher(betterproto.Message):
    """/ \brief Information about a message publisher."""

    # / \brief ZeroMQ control address of the publisher./ \todo(caguero) Is this
    # the same as 'socket_id' in the/ ServicePublisher message?
    ctrl: str = betterproto.string_field(1)
    # / \brief Message type advertised by this publisher.
    msg_type: str = betterproto.string_field(2)
    # / \brief Whether the publication has been throttled.
    throttled: bool = betterproto.bool_field(3)
    # / \brief The maximum number of messages per second to be published.
    msgs_per_sec: int = betterproto.uint64_field(4)


@dataclass
class DiscoveryPublisherServicePublisher(betterproto.Message):
    """/ \brief Information about service provider."""

    # / \brief ZeroMQ socket ID used by this publisher.
    socket_id: str = betterproto.string_field(1)
    # / \brief The name of the request's protobuf message advertised.
    request_type: str = betterproto.string_field(2)
    # / \brief The name of the response's protobuf message advertised.
    response_type: str = betterproto.string_field(3)


@dataclass
class Double(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Double data
    data: float = betterproto.double_field(2)


@dataclass
class Double_V(betterproto.Message):
    # / \brief Vector of double data
    data: List[float] = betterproto.double_field(1)


@dataclass
class Duration(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Seconds
    sec: int = betterproto.int64_field(2)
    # / \brief Nanoseconds
    nsec: int = betterproto.int32_field(3)


@dataclass
class Empty(betterproto.Message):
    # / \brief Unused field.
    unused: bool = betterproto.bool_field(1)


@dataclass
class Light(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    name: str = betterproto.string_field(2)
    type: "LightLightType" = betterproto.enum_field(3)
    pose: "Pose" = betterproto.message_field(4)
    diffuse: "Color" = betterproto.message_field(5)
    specular: "Color" = betterproto.message_field(6)
    attenuation_constant: float = betterproto.float_field(7)
    attenuation_linear: float = betterproto.float_field(8)
    attenuation_quadratic: float = betterproto.float_field(9)
    direction: "Vector3d" = betterproto.message_field(10)
    range: float = betterproto.float_field(11)
    cast_shadows: bool = betterproto.bool_field(12)
    spot_inner_angle: float = betterproto.float_field(13)
    spot_outer_angle: float = betterproto.float_field(14)
    spot_falloff: float = betterproto.float_field(15)
    # / \brief Unique id of the light
    id: int = betterproto.uint32_field(16)
    # / \brief Unique id of light's parent
    parent_id: int = betterproto.uint32_field(17)


@dataclass
class GPSSensor(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Position sensing. Consists of horizontal and vertical noise/
    # properties
    position: "GPSSensorSensing" = betterproto.message_field(2)
    # / \brief Velocity sensing. Consists of horizontal and vertical noise/
    # properties
    velocity: "GPSSensorSensing" = betterproto.message_field(3)


@dataclass
class GPSSensorSensing(betterproto.Message):
    """/ \brief Sensing information"""

    # / \brief Horizontal noise
    horizontal_noise: "SensorNoise" = betterproto.message_field(1)
    # / \brief Vertical noise
    vertical_noise: "SensorNoise" = betterproto.message_field(2)


@dataclass
class IMUSensor(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Angular velocity information
    angular_velocity: "IMUSensorAngularVelocity" = betterproto.message_field(2)
    # / \brief Linear acceleration information
    linear_acceleration: "IMUSensorLinearAcceleration" = betterproto.message_field(3)
    # / \brief Orientation reference frame information.
    orientation_ref_frame: "IMUSensorOrientationReferenceFrame" = (
        betterproto.message_field(4)
    )


@dataclass
class IMUSensorAngularVelocity(betterproto.Message):
    """/ \brief Angular velocity information"""

    # / \brief Noise about the x-axis
    x_noise: "SensorNoise" = betterproto.message_field(1)
    # / \brief Noise about the y-axis
    y_noise: "SensorNoise" = betterproto.message_field(2)
    # / \brief Noise about the z-axis
    z_noise: "SensorNoise" = betterproto.message_field(3)


@dataclass
class IMUSensorLinearAcceleration(betterproto.Message):
    """/ \brief Linear acceleration information"""

    # / \brief Noise about the x-axis
    x_noise: "SensorNoise" = betterproto.message_field(1)
    # / \brief Noise about the y-axis
    y_noise: "SensorNoise" = betterproto.message_field(2)
    # / \brief Noise about the z-axis
    z_noise: "SensorNoise" = betterproto.message_field(3)


@dataclass
class IMUSensorOrientationReferenceFrame(betterproto.Message):
    """/ \brief Orientation reference frame information"""

    # / \brief This string represents special hardcoded use cases that are/
    # commonly seen with typical robot IMU's:/   - CUSTOM: use Euler angle
    # custom_rpy orientation specification./             The orientation of the
    # IMU's reference frame is defined/             by adding the custom_rpy
    # rotation/             to the parent_frame./   - NED: The IMU XYZ aligns
    # with NED, where NED orientation relative/          to the world/
    # is defined by the SphericalCoordinates class./   - ENU: The IMU XYZ aligns
    # with ENU, where ENU orientation relative/          to the world is defined
    # by the SphericalCoordinates class./   - NWU: The IMU XYZ aligns with NWU,
    # where NWU orientation relative/          to the world is defined by the
    # SphericalCoordinates class./   - GRAV_UP: where direction of gravity maps
    # to IMU reference frame/              Z-axis with Z-axis pointing in the
    # opposite direction of/              gravity. IMU reference frame X-axis
    # direction is defined/              by GravityDirX(). Note if GravityDirX()
    # is parallel to/              gravity direction, this configuration fails.
    # Otherwise,/              IMU reference frame X-axis is defined by
    # projection of/              GravtyDirX onto a plane normal to the gravity
    # vector./              IMU reference frame Y-axis is a vector orthogonal to/
    # both X and Z axis following the right hand rule./  - GRAV_DOWN: where
    # direction of gravity maps to IMU reference frame/               Z-axis with
    # Z-axis pointing in the direction of gravity./               IMU reference
    # frame X-axis direction is defined by/               GravityDirX(). Note if
    # GravityDirX() is parallel to/               gravity direction, this
    # configuration fails. Otherwise,/               IMU reference frame X-axis
    # is defined by projection of/               GravityDirX() onto a plane
    # normal to the gravity vector./               IMU reference frame Y-axis is
    # a vector orthogonal to both/               X and Z axis following the right
    # hand rule.
    localization: str = betterproto.string_field(1)
    # / \brief This field and custom_rpy_parent_frame are used when/ Localization
    # is set to CUSTOM. Orientation/ (fixed axis roll, pitch yaw) transform from
    # ParentFrame to this IMU's/ reference frame.// Some common examples are:/  -
    # IMU reports in its local frame on boot. IMU sensor frame is the/
    # reference frame. Example: parent_frame="", custom_rpy="0 0 0"/  - IMU
    # reports in Gazebo world frame./    Example sdf: parent_frame="world",
    # custom_rpy="0 0 0"/  - IMU reports in NWU frame. Uses SphericalCoordinates
    # class to/    determine world frame in relation to magnetic north and
    # gravity;/    i.e. rotation between North-West-Up and world (+X,+Y,+Z) frame
    # is/    defined by SphericalCoordinates class./    Example sdf given world
    # is NWU: parent_frame="world",/    custom_rpy="0 0 0"/  - IMU reports in NED
    # frame. Uses SphericalCoordinates class to/    determine world frame in
    # relation to magnetic north and gravity;/    i.e. rotation between North-
    # East-Down and world (+X,+Y,+Z) frame is/    defined by SphericalCoordinates
    # class./    Example sdf given world is NWU: parent_frame="world",/
    # custom_rpy="M_PI 0 0"/  - IMU reports in ENU frame. Uses
    # SphericalCoordinates class to/    determine world frame in relation to
    # magnetic north and gravity;/    i.e. rotation between East-North-Up and
    # world (+X,+Y,+Z) frame is/    defined by SphericalCoordinates class./
    # Example sdf given world is NWU: parent_frame="world",/    custom_rpy="0 0
    # -0.5*M_PI"/  - IMU reports in ROS optical frame as described in/
    # http://www.ros.org/reps/rep-0103.html#suffix-frames, which is/
    # (z-forward, x-left to right when facing +z, y-top to bottom when/    facing
    # +z). (default gazebo camera is +x:view direction, +y:left,/    +z:up)./
    # Example sdf: parent_frame="local", custom_rpy="-0.5*M_PI 0 -0.5*M_PI"
    custom_rpy: "Vector3d" = betterproto.message_field(2)
    # / \brief The name of parent frame which the custom_rpy transform is/
    # defined relative to. It can be any valid fully scoped link name or the/
    # special reserved "world" frame. If left empty, use the sensor's own/ local
    # frame.
    custom_rpy_parent_frame: str = betterproto.string_field(3)
    # / \brief Used when localization is set to GRAV_UP or GRAV_DOWN, a/
    # projection of this vector into a plane that is orthogonal to the/ gravity
    # vector defines the direction of the IMU reference frame's/ X-axis.
    # grav_dir_x is  defined in the coordinate frame as defined by/ the
    # parent_frame element.
    gravity_dir_x: "Vector3d" = betterproto.message_field(4)
    # / \brief The name of parent frame which the GravityDirX vector is/ defined
    # relative to. It can be any valid fully scoped link name or the/ special
    # reserved "world" frame. If left empty, use the sensor's own/ local frame.
    gravity_dir_x_parent_frame: str = betterproto.string_field(5)


@dataclass
class LidarSensor(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    display_scan: bool = betterproto.bool_field(2)
    horizontal_samples: int = betterproto.int32_field(3)
    horizontal_resolution: float = betterproto.double_field(4)
    horizontal_min_angle: float = betterproto.double_field(5)
    horizontal_max_angle: float = betterproto.double_field(6)
    vertical_samples: int = betterproto.int32_field(7)
    vertical_resolution: float = betterproto.double_field(8)
    vertical_min_angle: float = betterproto.double_field(9)
    vertical_max_angle: float = betterproto.double_field(10)
    range_min: float = betterproto.double_field(11)
    range_max: float = betterproto.double_field(12)
    range_resolution: float = betterproto.double_field(13)
    noise: "SensorNoise" = betterproto.message_field(14)


@dataclass
class LogicalCameraSensor(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Near clipping plane of the view frustum in meters.
    near_clip: float = betterproto.double_field(2)
    # / \brief Far clipping plane of the view frustum in meters.
    far_clip: float = betterproto.double_field(3)
    # / \brief Horizontal field of view in radians.
    horizontal_fov: float = betterproto.double_field(4)
    # / \brief Near and far clipping plane aspect ratio (width/height).
    aspect_ratio: float = betterproto.double_field(5)


@dataclass
class MagnetometerSensor(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Noise about the x-axis
    x_noise: "SensorNoise" = betterproto.message_field(2)
    # / \brief Noise about the y-axis
    y_noise: "SensorNoise" = betterproto.message_field(3)
    # / \brief Noise about the z-axis
    z_noise: "SensorNoise" = betterproto.message_field(4)


@dataclass
class Sensor(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Name of the sensor
    name: str = betterproto.string_field(2)
    # / \brief Id of the sensor
    id: int = betterproto.uint32_field(3)
    # / \brief Name of the parent, usually a link or joint.
    parent: str = betterproto.string_field(4)
    # / \brief Id of the parent, usually a link or joint.
    parent_id: int = betterproto.uint32_field(5)
    # / \brief Sensor type
    type: str = betterproto.string_field(6)
    # / \brief True indicates that the sensor should always/ produce data,
    # instead of producing data only when/ a consumer is connected to the data
    # topic
    always_on: bool = betterproto.bool_field(7)
    # / \brief Refresh rate
    update_rate: float = betterproto.double_field(8)
    # / \brief Sensor pose
    pose: "Pose" = betterproto.message_field(9)
    # / \brief Description of a camera sensor
    camera: "CameraSensor" = betterproto.message_field(10)
    # / \brief Description of a contact sensor
    contact: "ContactSensor" = betterproto.message_field(11)
    # / \brief True value indicates that sensor data should be/ visualized in the
    # GUI
    visualize: bool = betterproto.bool_field(12)
    # / \brief Topic on which sensor data is published
    topic: str = betterproto.string_field(13)
    # / \brief Description of a logical camera sensor
    logical_camera: "LogicalCameraSensor" = betterproto.message_field(14)
    # / \brief Description of a gps sensor
    gps: "GPSSensor" = betterproto.message_field(15)
    # / \brief Description of an IMU sensor
    imu: "IMUSensor" = betterproto.message_field(16)
    # / \brief Description of a Magnetometer sensor
    magnetometer: "MagnetometerSensor" = betterproto.message_field(17)
    # / \brief Description of an Altimeter sensor.
    altimeter: "AltimeterSensor" = betterproto.message_field(18)
    # / \brief Description of an Air Pressure sensor.
    air_pressure: "AirPressureSensor" = betterproto.message_field(19)
    # / \brief Description of a lidar sensor
    lidar: "LidarSensor" = betterproto.message_field(20)


@dataclass
class Joint(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    name: str = betterproto.string_field(2)
    id: int = betterproto.uint32_field(3)
    type: "JointType" = betterproto.enum_field(4)
    parent: str = betterproto.string_field(5)
    parent_id: int = betterproto.uint32_field(6)
    child: str = betterproto.string_field(7)
    child_id: int = betterproto.uint32_field(8)
    pose: "Pose" = betterproto.message_field(9)
    axis1: "Axis" = betterproto.message_field(10)
    axis2: "Axis" = betterproto.message_field(11)
    cfm: float = betterproto.double_field(12)
    bounce: float = betterproto.double_field(13)
    fudge_factor: float = betterproto.double_field(14)
    limit_cfm: float = betterproto.double_field(15)
    limit_erp: float = betterproto.double_field(16)
    suspension_cfm: float = betterproto.double_field(17)
    suspension_erp: float = betterproto.double_field(18)
    gearbox: "JointGearbox" = betterproto.message_field(19)
    screw: "JointScrew" = betterproto.message_field(20)
    sensor: List["Sensor"] = betterproto.message_field(21)


@dataclass
class JointGearbox(betterproto.Message):
    # / \brief Gearbox joint reference body link
    gearbox_reference_body: str = betterproto.string_field(1)
    # / \brief Gearbox ratio.
    gearbox_ratio: float = betterproto.double_field(2)


@dataclass
class JointScrew(betterproto.Message):
    # / \brief Screw joint thread pitch.
    thread_pitch: float = betterproto.double_field(1)


@dataclass
class Inertial(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    mass: float = betterproto.double_field(2)
    pose: "Pose" = betterproto.message_field(3)
    ixx: float = betterproto.double_field(4)
    ixy: float = betterproto.double_field(5)
    ixz: float = betterproto.double_field(6)
    iyy: float = betterproto.double_field(7)
    iyz: float = betterproto.double_field(8)
    izz: float = betterproto.double_field(9)


@dataclass
class Projector(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    name: str = betterproto.string_field(2)
    texture: str = betterproto.string_field(3)
    pose: "Pose" = betterproto.message_field(4)
    fov: float = betterproto.double_field(5)
    near_clip: float = betterproto.double_field(6)
    far_clip: float = betterproto.double_field(7)
    enabled: bool = betterproto.bool_field(8)


@dataclass
class Link(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    id: int = betterproto.uint32_field(2)
    name: str = betterproto.string_field(3)
    self_collide: bool = betterproto.bool_field(4)
    gravity: bool = betterproto.bool_field(5)
    kinematic: bool = betterproto.bool_field(6)
    enabled: bool = betterproto.bool_field(7)
    density: "Density" = betterproto.message_field(8)
    inertial: "Inertial" = betterproto.message_field(9)
    pose: "Pose" = betterproto.message_field(10)
    visual: List["Visual"] = betterproto.message_field(11)
    collision: List["Collision"] = betterproto.message_field(12)
    sensor: List["Sensor"] = betterproto.message_field(13)
    projector: List["Projector"] = betterproto.message_field(14)
    canonical: bool = betterproto.bool_field(15)
    # / \brief A vector of batteries attached to this link.
    battery: List["Battery"] = betterproto.message_field(16)
    # / \brief A vector of lights attached to this link
    light: List["Light"] = betterproto.message_field(17)


@dataclass
class Model(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Name of the model.
    name: str = betterproto.string_field(2)
    # / \brief Unique ID associated with the model
    id: int = betterproto.uint32_field(3)
    # / \brief True if the model is statc.
    is_static: bool = betterproto.bool_field(4)
    # / \brief Pose of the model.
    pose: "Pose" = betterproto.message_field(5)
    # / \brief Information about the joints in this model.
    joint: List["Joint"] = betterproto.message_field(6)
    # / \brief Information about the links in this model.
    link: List["Link"] = betterproto.message_field(7)
    # / \brief True if the model was deleted.
    deleted: bool = betterproto.bool_field(8)
    # / \brief Information about the visuals in this model.
    visual: List["Visual"] = betterproto.message_field(9)
    # / \brief Scaling factor applied to the model
    scale: "Vector3d" = betterproto.message_field(10)
    # / \brief True if self collide is enabled.
    self_collide: bool = betterproto.bool_field(11)
    # / \brief An array of nested models.
    model: List["Model"] = betterproto.message_field(12)
    # / \brief Axis aligned bounding box for the model. The center of the /
    # bounding box should coincide with the model's pose.
    bounding_box: "AxisAlignedBox" = betterproto.message_field(13)


@dataclass
class EntityFactory(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief SDF description in string format.
    sdf: str = betterproto.string_field(2, group="from")
    # / \brief Full path to SDF file.
    sdf_filename: str = betterproto.string_field(3, group="from")
    # / \brief Description of model to be inserted.
    model: "Model" = betterproto.message_field(4, group="from")
    # / \brief Description of light to be inserted.
    light: "Light" = betterproto.message_field(5, group="from")
    # / \brief Name of entity to clone.
    clone_name: str = betterproto.string_field(6, group="from")
    # / \brief Pose where the entity will be spawned in the world.
    pose: "Pose" = betterproto.message_field(7)
    # / \brief New name for the entity, overrides the name on the SDF.
    name: str = betterproto.string_field(8)
    # / \brief Whether the server is allowed to rename the entity in case of/
    # overlap with existing entities.
    allow_renaming: bool = betterproto.bool_field(9)
    # / \brief The pose will be defined relative to this frame. If left empty,/
    # the "world" frame will be used.
    relative_to: str = betterproto.string_field(10)


@dataclass
class EntityFactory_V(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief The set of entity factory messages.
    data: List["EntityFactory"] = betterproto.message_field(2)


@dataclass
class Float(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Float data
    data: float = betterproto.float_field(2)


@dataclass
class Float_V(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Vector of float data
    data: List[float] = betterproto.float_field(2)


@dataclass
class Fluid(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # Name of the fluid
    name: str = betterproto.string_field(2)
    # Position of each particle in the fluid.
    position: List["Vector3d"] = betterproto.message_field(3)


@dataclass
class FluidPressure(betterproto.Message):
    """/ \brief Fluid pressure data."""

    # Other Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Pressure reading in Pascals
    pressure: float = betterproto.double_field(2)
    # / \brief Pressure variance. 0 is interpreted as variance unknown.
    variance: float = betterproto.double_field(3)


@dataclass
class Fog(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    type: "FogFogType" = betterproto.enum_field(2)
    color: "Color" = betterproto.message_field(3)
    density: float = betterproto.float_field(4)
    start: float = betterproto.float_field(5)
    end: float = betterproto.float_field(6)


@dataclass
class Version(betterproto.Message):
    # / \brief Major version.
    major: int = betterproto.int32_field(1)
    # / \brief Minor version.
    minor: int = betterproto.int32_field(2)
    # / \brief Patch version.
    patch: int = betterproto.int32_field(3)
    # / \brief Pre-release version.
    prerelease: str = betterproto.string_field(4)
    # / \brief Build version.
    build: str = betterproto.string_field(5)


@dataclass
class VersionRange(betterproto.Message):
    # / \brief Min version.
    min: "Version" = betterproto.message_field(1)
    # / \brief Max version.
    max: "Version" = betterproto.message_field(2)


@dataclass
class VersionedName(betterproto.Message):
    # / \brief Version information.
    version: "Version" = betterproto.message_field(1)
    # / \brief Name associated with the version.
    name: str = betterproto.string_field(2)


@dataclass
class FuelMetadata(betterproto.Message):
    model: "FuelMetadataModel" = betterproto.message_field(1, group="resource_type")
    world: "FuelMetadataWorld" = betterproto.message_field(2, group="resource_type")
    # / \brief Name of the resource.
    name: str = betterproto.string_field(3)
    # / \brief Description of the resource.
    description: str = betterproto.string_field(4)
    # / \brief Version number of the resource. This version is set by Fuel.
    version: int = betterproto.int32_field(5)
    # / \brief Authors of this resource.
    authors: List["FuelMetadataContact"] = betterproto.message_field(6)
    # / \brief Legal information, such as copyright and license specificiations.
    legal: "FuelMetadataLegal" = betterproto.message_field(7)
    # / \brief Tags for a resource.
    tags: List[str] = betterproto.string_field(8)
    # A list of key-value pairs that can contain arbitrary user data.
    annotations: Dict[str, str] = betterproto.map_field(
        9, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    # / \brief Resources that this resource depends on./ \todo(nkoenig) This
    # field is currently not used.
    dependencies: List["FuelMetadataDependency"] = betterproto.message_field(10)
    # / \brief List of tools/libraries with version numbers that are compatible/
    # with this resource.
    compatibilities: List["FuelMetadataCompatibility"] = betterproto.message_field(11)
    # / \brief Categories associated with this resource.
    categories: "FuelMetadataCategories" = betterproto.message_field(12)


@dataclass
class FuelMetadataContact(betterproto.Message):
    """/ \brief Contact information."""

    # / \brief Contact name.
    name: str = betterproto.string_field(1)
    # / \brief Contact email.
    email: str = betterproto.string_field(2)


@dataclass
class FuelMetadataLegal(betterproto.Message):
    """
    / \brief Legal information, including copyright and license specifications.
    """

    # / \brief Copyright information, such as "Copyright 1974, John Doe"
    copyright: str = betterproto.string_field(1)
    # / \brief License, such as "Apache-2.0"
    license: str = betterproto.string_field(2)


@dataclass
class FuelMetadataModel(betterproto.Message):
    """/ \brief Information about a model resource."""

    # / \brief Main model file, e.g. "model.sdf".
    file: str = betterproto.string_field(1)
    # / \brief Name and version of the file format used by the file.
    file_format: "VersionedName" = betterproto.message_field(2)


@dataclass
class FuelMetadataWorld(betterproto.Message):
    """/ \brief Information about a world resource."""

    # / \brief Main world file, e.g. "world.sdf".
    file: str = betterproto.string_field(1)
    # / \brief Name and version of the file format used by the file.
    file_format: "VersionedName" = betterproto.message_field(2)


@dataclass
class FuelMetadataDependency(betterproto.Message):
    """/ \brief Definition of a dependency"""

    # / \brief Dependency uri.
    uri: str = betterproto.string_field(1)


@dataclass
class FuelMetadataCompatibility(betterproto.Message):
    """
    / \brief A message containing a tool name and a version or range of/
    versions, e.g./   tools { name: "bullet" version_range { min: {major: 3 } }
    } }/   tools { name: "gazebo" version { major: 11 } }
    """

    # / \brief Name of the tool/library.
    name: str = betterproto.string_field(1)
    # / \brief Exact version that the model is compatible with.
    version: "Version" = betterproto.message_field(2, group="version_type")
    # / \brief A range of compatible versions.
    version_range: "VersionRange" = betterproto.message_field(3, group="version_type")


@dataclass
class FuelMetadataCategories(betterproto.Message):
    """
    / \brief Categories associated with this resource. The set of/ Fuel
    categories are available at/
    https://fuel.ignitionrobotics.org/1.0/categories.// A limited number of
    categories can be assigned to a Fuel resource.
    """

    # / \brief First category.
    first: str = betterproto.string_field(1)
    # / \brief Second category.
    second: str = betterproto.string_field(2)


@dataclass
class GPS(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    link_name: str = betterproto.string_field(2)
    latitude_deg: float = betterproto.double_field(3)
    longitude_deg: float = betterproto.double_field(4)
    altitude: float = betterproto.double_field(5)
    velocity_east: float = betterproto.double_field(6)
    velocity_north: float = betterproto.double_field(7)
    velocity_up: float = betterproto.double_field(8)


@dataclass
class TrackVisual(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Name of the visual to track
    name: str = betterproto.string_field(2)
    # / \brief Id of the visual to track
    id: int = betterproto.uint32_field(3)
    # / \brief True to have the tracking camera inherit the orientation of/ the
    # tracked visual.
    inherit_orientation: bool = betterproto.bool_field(4)
    # / \brief Minimum follow distance
    min_dist: float = betterproto.double_field(5)
    # / \brief Maximum follow distance
    max_dist: float = betterproto.double_field(6)
    # / \brief If set to true, the position of the camera is fixed.
    static: bool = betterproto.bool_field(7)
    # / \brief If set to true, the position of the camera is relative to the/
    # model reference frame.
    use_model_frame: bool = betterproto.bool_field(8)
    # / \brief Position of the camera.
    xyz: "Vector3d" = betterproto.message_field(9)
    # / \brief If set to true, the camera inherits the yaw rotation of the model.
    inherit_yaw: bool = betterproto.bool_field(10)


@dataclass
class GUICamera(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    name: str = betterproto.string_field(2)
    view_controller: str = betterproto.string_field(3)
    pose: "Pose" = betterproto.message_field(4)
    track: "TrackVisual" = betterproto.message_field(5)
    # / \brief Type of projection: "perspective" or "orthographic".
    projection_type: str = betterproto.string_field(6)


@dataclass
class GUI(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    fullscreen: bool = betterproto.bool_field(2)
    camera: "GUICamera" = betterproto.message_field(3)
    plugin: List["Plugin"] = betterproto.message_field(4)


@dataclass
class Hydra(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # Info for the right paddle
    right: "HydraPaddle" = betterproto.message_field(2)
    # Info for the left paddle
    left: "HydraPaddle" = betterproto.message_field(3)


@dataclass
class HydraPaddle(betterproto.Message):
    # Pose of the paddle
    pose: "Pose" = betterproto.message_field(1)
    # The button labeled LB
    button_bumper: bool = betterproto.bool_field(2)
    # Button 1
    button_1: bool = betterproto.bool_field(3)
    # Button 2
    button_2: bool = betterproto.bool_field(4)
    # Button 3
    button_3: bool = betterproto.bool_field(5)
    # Button 4
    button_4: bool = betterproto.bool_field(6)
    # Button that is activated by pressing down on the joystick.
    button_joy: bool = betterproto.bool_field(7)
    # The button located between button 1 and 2.
    button_center: bool = betterproto.bool_field(8)
    # Range(-1, 1) where -1 == back, and +1 == forward.
    joy_x: float = betterproto.double_field(9)
    # Range(-1, 1) where -1 == left, and +1 == right.
    joy_y: float = betterproto.double_field(10)
    # Range(0, 1) where 0 is no press, and 1 is full press.
    trigger: float = betterproto.double_field(11)


@dataclass
class IMU(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    entity_name: str = betterproto.string_field(2)
    orientation: "Quaternion" = betterproto.message_field(3)
    angular_velocity: "Vector3d" = betterproto.message_field(4)
    linear_acceleration: "Vector3d" = betterproto.message_field(5)


@dataclass
class Int32(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Integer data
    data: int = betterproto.int32_field(2)


@dataclass
class Int32_V(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Vector of int data
    data: List[int] = betterproto.int32_field(2)


@dataclass
class Int64(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Integer data
    data: int = betterproto.int64_field(2)


@dataclass
class Int64_V(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Vector of int data
    data: List[int] = betterproto.int64_field(2)


@dataclass
class JointAnimation(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    model_name: str = betterproto.string_field(2)
    joint: List["JointAnimationJoint"] = betterproto.message_field(3)
    time: List["Time"] = betterproto.message_field(4)


@dataclass
class JointAnimationJoint(betterproto.Message):
    name: List[str] = betterproto.string_field(1)
    angle: List[float] = betterproto.double_field(2)


@dataclass
class PID(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    target: float = betterproto.double_field(2)
    p_gain: float = betterproto.double_field(3)
    i_gain: float = betterproto.double_field(4)
    d_gain: float = betterproto.double_field(5)
    i_max: float = betterproto.double_field(6)
    i_min: float = betterproto.double_field(7)
    limit: float = betterproto.double_field(8)
    target_optional: "Double" = betterproto.message_field(9)
    p_gain_optional: "Double" = betterproto.message_field(10)
    i_gain_optional: "Double" = betterproto.message_field(11)
    d_gain_optional: "Double" = betterproto.message_field(12)
    i_max_optional: "Double" = betterproto.message_field(13)
    i_min_optional: "Double" = betterproto.message_field(14)
    limit_optional: "Double" = betterproto.message_field(15)


@dataclass
class JointCmd(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    name: str = betterproto.string_field(2)
    axis: int = betterproto.int32_field(3)
    force: float = betterproto.double_field(4)
    position: "PID" = betterproto.message_field(5)
    velocity: "PID" = betterproto.message_field(6)
    reset: bool = betterproto.bool_field(7)
    force_optional: "Double" = betterproto.message_field(8)


@dataclass
class JointTrajectoryPoint(betterproto.Message):
    # / \brief Position of each joint relative to their "0" position. Units are/
    # dependent on the joint type, where radians are used for revolute or/
    # continuous joints, and meters for prismatic joints
    positions: List[float] = betterproto.double_field(1)
    # / \brief Rate of change in position of each joint. Units are dependent on/
    # the joint type, where radians/second are used for revolute or continuous/
    # joints, and meters/second for prismatic joints
    velocities: List[float] = betterproto.double_field(2)
    # / \brief Rate of change in velocity of each joint. Units are dependent on/
    # the joint type, where radians/second^2 are used for revolute or/ continuous
    # joints, and meters/second^2 for prismatic joints
    accelerations: List[float] = betterproto.double_field(3)
    # / \brief Torque or force applied at each joint. Units are dependent on the/
    # joint type, where newton-meters are used for revolute or continuous/ joints
    # (torque), and newtons for prismatic joints (force)
    effort: List[float] = betterproto.double_field(4)
    # / \brief Desired time from the beginning of trajectory execution until/
    # this trajectory point should be reached. This value must be strictly/
    # increasing for consecutive points
    time_from_start: "Duration" = betterproto.message_field(5)


@dataclass
class JointTrajectory(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Ordered list of joint names that must be active during execution/
    # of this trajectory. The order shall correspond to the values in each/
    # trajectory point
    joint_names: List[str] = betterproto.string_field(2)
    # / \brief Ordered list of time-parameterised trajectory points, which can/
    # describe positions, velocities, accelerations and/or effort for all/ active
    # joints at each point in time. All points must be ordered/ according to
    # their time from start, which must be strictly increasing
    points: List["JointTrajectoryPoint"] = betterproto.message_field(3)


@dataclass
class Joy(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # Axis data from a joystick.
    axes: List[float] = betterproto.float_field(2)
    # Button data from a joystick
    buttons: List[int] = betterproto.int32_field(3)


@dataclass
class Joystick(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # Translation measurements along the x,y,z axes. These values should be
    # normalized to the range -1...1
    translation: "Vector3d" = betterproto.message_field(2)
    # Rotation measurements about the x,y,z  axes. These values should be
    # normalized to the range -1...1
    rotation: "Vector3d" = betterproto.message_field(3)
    # Button measurements
    buttons: List[int] = betterproto.int32_field(4)


@dataclass
class LaserScan(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    frame: str = betterproto.string_field(2)
    world_pose: "Pose" = betterproto.message_field(3)
    angle_min: float = betterproto.double_field(4)
    angle_max: float = betterproto.double_field(5)
    angle_step: float = betterproto.double_field(6)
    range_min: float = betterproto.double_field(7)
    range_max: float = betterproto.double_field(8)
    count: int = betterproto.uint32_field(9)
    vertical_angle_min: float = betterproto.double_field(10)
    vertical_angle_max: float = betterproto.double_field(11)
    vertical_angle_step: float = betterproto.double_field(12)
    vertical_count: int = betterproto.uint32_field(13)
    ranges: List[float] = betterproto.double_field(14)
    intensities: List[float] = betterproto.double_field(15)


@dataclass
class LinkData(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    name: str = betterproto.string_field(2)
    linear_velocity: "Vector3d" = betterproto.message_field(3)
    angular_velocity: "Vector3d" = betterproto.message_field(4)


@dataclass
class LogControl(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    start: bool = betterproto.bool_field(2)
    stop: bool = betterproto.bool_field(3)
    paused: bool = betterproto.bool_field(4)
    base_path: str = betterproto.string_field(5)
    encoding: str = betterproto.string_field(6)
    record_resources: str = betterproto.string_field(7)


@dataclass
class LogPlaybackControl(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Pause/play the log file.
    pause: bool = betterproto.bool_field(2)
    # / \brief Make a relative jump. The value indicates the number of/
    # iterations that will be executed at once. If a negative/        value is
    # specified, the playback will jump backwards.
    multi_step: int = betterproto.sint32_field(3)
    # / \brief Jump to the beginning of the log file.
    rewind: bool = betterproto.bool_field(4)
    # / \brief Jump to the end of the log file.
    forward: bool = betterproto.bool_field(5)
    # / \brief Jump to a specific simulation time in the log file. The/
    # playback service will load the frame with the closest/        simulation
    # time bigger than the "seek" value.
    seek: "Time" = betterproto.message_field(6)


@dataclass
class LogPlaybackStatistics(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Log start time
    start_time: "Time" = betterproto.message_field(2)
    # / \brief Log end time
    end_time: "Time" = betterproto.message_field(3)


@dataclass
class LogStatus(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    sim_time: "Time" = betterproto.message_field(2)
    log_file: "LogStatusLogFile" = betterproto.message_field(3)


@dataclass
class LogStatusLogFile(betterproto.Message):
    uri: str = betterproto.string_field(1)
    base_path: str = betterproto.string_field(2)
    full_path: str = betterproto.string_field(3)
    size: float = betterproto.float_field(4)
    size_units: "LogStatusLogFileUnits" = betterproto.enum_field(5)
    record_resources: bool = betterproto.bool_field(6)


@dataclass
class LogicalCameraImage(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Pose of the logical camera.
    pose: "Pose" = betterproto.message_field(2)
    # / \brief All the models seen by the LogicalCamera
    model: List["LogicalCameraImageModel"] = betterproto.message_field(3)


@dataclass
class LogicalCameraImageModel(betterproto.Message):
    """
    / \brief Information about a model that is reported by a/
    LogicalCameraSensor
    """

    # / \brief Name of the detected model
    name: str = betterproto.string_field(1)
    # / \brief Pose of the detected model. The pose is relative to the/ logical
    # camera's pose.
    pose: "Pose" = betterproto.message_field(2)


@dataclass
class Magnetometer(betterproto.Message):
    """/ \brief Message that encapsulates sensor data from a magnetometer."""

    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Magnetic field strength (in Tesla) along body-frame axis
    field_tesla: "Vector3d" = betterproto.message_field(2)


@dataclass
class Marker(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief The action to take// Relevant Type: all
    action: "MarkerAction" = betterproto.enum_field(2)
    # / \brief Namespace of the marker. A namespace groups id's together.//
    # Relevant Action: ADD_MODIFY, DELETE_MARKER, DELETE_ALL
    ns: str = betterproto.string_field(3)
    # / \brief The id within the namespace of the visual. Each marker has a/
    # unique id. It's up to the user to select id values.// Relevant Action:
    # ADD_MODIFY, DELETE_MARKER// Relevant Type: all
    id: int = betterproto.uint64_field(4)
    # / \brief The layer the visual belongs to.// Relevant Action: ADD_MODIFY//
    # Relevant Type: all
    layer: int = betterproto.int32_field(5)
    # / \brief The type of geometry.// Relevant Action: ADD_MODIFY
    type: "MarkerType" = betterproto.enum_field(6)
    # / \brief How long to keep the visual alive before deletion. A value of /
    # zero indicates forever. The lifetime is based on simulation-time, not/
    # real-time.// Relevant Action: ADD_MODIFY// Relevant Type: all
    lifetime: "Time" = betterproto.message_field(7)
    # / \brief Pose of the marker// Relevant Action: ADD_MODIFY// Relevant Type:
    # all
    pose: "Pose" = betterproto.message_field(8)
    # / \brief Scale of the marker.// Relevant Action: ADD_MODIFY// Relevant
    # Type: all
    scale: "Vector3d" = betterproto.message_field(9)
    # / \brief Marker color// Relevant Action: ADD_MODIFY// Relevant Type: all
    material: "Material" = betterproto.message_field(10)
    # / \brief Used to specify geometry for a LINE_STRIP, LINE_LIST, POINTS,/
    # TRIANGLE_LIST, TRIANGLE_FAN, TRIANGLE_STRIP// Relevant Action: ADD_MODIFY//
    # Relevant Type: LINE_STRIP, LINE_LIST, POINTS, TRIANGLE_FAN, TRIANGLE_LIST,/
    # TRIANGLE_STRIP
    point: List["Vector3d"] = betterproto.message_field(11)
    # / \brief String to display. Only used for TEXT marker.// Relevant Action:
    # ADD_MODIFY// Relevant Type: TEXT
    text: str = betterproto.string_field(12)
    # / \brief Attach this marker to a "parent" visual.// Relevant Action:
    # ADD_MODIFY// Relevant Type: all
    parent: str = betterproto.string_field(13)
    # / \brief Defines what cameras render the marker.// Relevant Action:
    # ADD_MODIFY// Relevant Type: all
    visibility: "MarkerVisibility" = betterproto.enum_field(14)


@dataclass
class Marker_V(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief List of marker messages.
    marker: List["Marker"] = betterproto.message_field(2)


@dataclass
class ModelConfiguration(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # Time when the pose should be enforced
    time: "Time" = betterproto.message_field(2)
    joint_names: List[str] = betterproto.string_field(3)
    joint_positions: List[float] = betterproto.double_field(4)
    # Specify model pose
    pose: "Pose" = betterproto.message_field(5)
    # Option to set model pose by specifying pose of link
    link_name: str = betterproto.string_field(6)


@dataclass
class Model_V(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    models: List["Model"] = betterproto.message_field(2)


@dataclass
class OccupancyGrid(betterproto.Message):
    # / \brief Optional header data. This should contain time of map validity/
    # and the coordinate frame ID.
    header: "Header" = betterproto.message_field(1)
    # / \brief Metadata for the map.
    info: "OccupancyGridMapMetaInfo" = betterproto.message_field(2)
    # / \brief The map data, in row-major order, starting with (0,0)./ Occupancy
    # probabilities are in the range [0,100].  Unknown is -1.
    data: bytes = betterproto.bytes_field(3)


@dataclass
class OccupancyGridMapMetaInfo(betterproto.Message):
    # / \brief The map load time
    map_load_time: "Time" = betterproto.message_field(1)
    # / \brief The map resolution (meters/cell)
    resolution: float = betterproto.double_field(2)
    # / \brief The map width (cells)
    width: int = betterproto.uint32_field(3)
    # / \brief The map height (cells)
    height: int = betterproto.uint32_field(4)
    # / \brief  The origin of the map.  This is the real-world pose of the/ cell
    # (0,0) in the map
    origin: "Pose" = betterproto.message_field(5)


@dataclass
class Twist(betterproto.Message):
    # / \brief Optional header data.
    header: "Header" = betterproto.message_field(1)
    # / \brief Lnear velocity in 3d space.
    linear: "Vector3d" = betterproto.message_field(2)
    # / \brief Angular velocity in 3d space.
    angular: "Vector3d" = betterproto.message_field(3)


@dataclass
class Odometry(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Estimated pose.
    pose: "Pose" = betterproto.message_field(2)
    # / \brief Estimated velocity.
    twist: "Twist" = betterproto.message_field(3)


@dataclass
class Pose_V(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    pose: List["Pose"] = betterproto.message_field(2)


@dataclass
class StringMsg_V(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    data: List[str] = betterproto.string_field(2)


@dataclass
class WebRequest(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    operation: str = betterproto.string_field(2)
    topic: str = betterproto.string_field(3)
    msg_type: str = betterproto.string_field(4)
    compression: str = betterproto.string_field(5)
    hz: float = betterproto.double_field(6)


@dataclass
class WorldStatistics(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Current simulation time
    sim_time: "Time" = betterproto.message_field(2)
    # / \brief Total time spent paused
    pause_time: "Time" = betterproto.message_field(3)
    # / \brief Current real time
    real_time: "Time" = betterproto.message_field(4)
    # / \brief Whether currently paused
    paused: bool = betterproto.bool_field(5)
    # / \brief Current iteration count
    iterations: int = betterproto.uint64_field(6)
    # / \brief Total number of models in the world
    model_count: int = betterproto.int32_field(7)
    # / \brief Statistics for log playback
    log_playback_stats: "LogPlaybackStatistics" = betterproto.message_field(8)
    # / \brief This factor expresses how much real time elapses with each step/
    # of simulation time./ E.g.: 0.5 means that 1 second in real time takes 2
    # seconds in simulation.
    real_time_factor: float = betterproto.double_field(9)
    # / \brief Iteration step size. It's zero when paused.
    step_size: "Time" = betterproto.message_field(10)


@dataclass
class Packet(betterproto.Message):
    topic: str = betterproto.string_field(1)
    type: str = betterproto.string_field(2)
    cmd_vel2d: "CmdVel2D" = betterproto.message_field(3, group="content")
    image: "Image" = betterproto.message_field(4, group="content")
    string_msg_v: "StringMsg_V" = betterproto.message_field(5, group="content")
    web_request: "WebRequest" = betterproto.message_field(6, group="content")
    pose: "Pose" = betterproto.message_field(7, group="content")
    doublev: "Double_V" = betterproto.message_field(8, group="content")
    pose_v: "Pose_V" = betterproto.message_field(9, group="content")
    time: "Time" = betterproto.message_field(10, group="content")
    clock: "Clock" = betterproto.message_field(11, group="content")
    world_stats: "WorldStatistics" = betterproto.message_field(12, group="content")


@dataclass
class Param(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief A set of name, value pairs.
    params: Dict[str, "Any"] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    # / \brief Params nested within this one.
    children: List["Param"] = betterproto.message_field(3)


@dataclass
class Param_V(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Repeated params.
    param: List["Param"] = betterproto.message_field(2)


@dataclass
class StringMsg(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    data: str = betterproto.string_field(2)


@dataclass
class ParticleEmitter(betterproto.Message):
    # / \brief Optional header data.
    header: "Header" = betterproto.message_field(1)
    # / \brief The emitter name.
    name: str = betterproto.string_field(2)
    # / \brief Unique Id.
    id: int = betterproto.uint32_field(3)
    # / \brief The emitter type.
    type: "ParticleEmitterEmitterType" = betterproto.enum_field(4)
    # / \brief The position of the emitter.
    pose: "Pose" = betterproto.message_field(5)
    # / The size of the emitter where the particles are sampled.
    size: "Vector3d" = betterproto.message_field(6)
    # / \brief How many particles per second should be emitted.
    rate: "Float" = betterproto.message_field(7)
    # / \brief The number of seconds the emitter is active.
    duration: "Float" = betterproto.message_field(8)
    # / \brief Whether particle emitter is enabled or not.
    emitting: "Boolean" = betterproto.message_field(9)
    # / \brief The particle dimensions (width, height, depth).
    particle_size: "Vector3d" = betterproto.message_field(10)
    # / \brief The number of seconds each particle will live for before/ being
    # destroyed.
    lifetime: "Float" = betterproto.message_field(11)
    # / \brief The material which all particles in the emitter will use.
    material: "Material" = betterproto.message_field(12)
    # / \brief The minimum velocity each particle is emitted (m/s).
    min_velocity: "Float" = betterproto.message_field(13)
    # / \brief The maximum velocity each particle is emitted (m/s).
    max_velocity: "Float" = betterproto.message_field(14)
    # / \brief The starting color of the particles.
    color_start: "Color" = betterproto.message_field(15)
    # / \brief The end color of the particles.
    color_end: "Color" = betterproto.message_field(16)
    # / \brief The amount by which to scale the particles in both x and y/
    # direction per second (screen coordinates).
    scale_rate: "Float" = betterproto.message_field(17)
    # / \brief The path to the color image used as an affector.
    color_range_image: "StringMsg" = betterproto.message_field(18)


@dataclass
class Physics(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    type: "PhysicsType" = betterproto.enum_field(2)
    solver_type: str = betterproto.string_field(3)
    min_step_size: float = betterproto.double_field(4)
    precon_iters: int = betterproto.int32_field(5)
    iters: int = betterproto.int32_field(6)
    sor: float = betterproto.double_field(7)
    cfm: float = betterproto.double_field(8)
    erp: float = betterproto.double_field(9)
    contact_max_correcting_vel: float = betterproto.double_field(10)
    contact_surface_layer: float = betterproto.double_field(11)
    gravity: "Vector3d" = betterproto.message_field(12)
    enable_physics: bool = betterproto.bool_field(13)
    real_time_factor: float = betterproto.double_field(14)
    real_time_update_rate: float = betterproto.double_field(15)
    max_step_size: float = betterproto.double_field(16)
    # The name of this physics profile (not to be confused with type)
    profile_name: str = betterproto.string_field(17)
    # / \brief Magnetic field
    magnetic_field: "Vector3d" = betterproto.message_field(18)


@dataclass
class Plugin_V(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Plugin messages.
    plugins: List["Plugin"] = betterproto.message_field(2)


@dataclass
class PointCloud(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    points: List["Vector3d"] = betterproto.message_field(2)


@dataclass
class PointCloudPacked(betterproto.Message):
    """
    / \brief (Copied from the ROS message): This message holds a collection of/
    N-dimensional points, which may contain additional information such as/
    normals, intensity, etc. The point data is stored as a binary blob, its/
    layout described by the contents of the "fields" array.// The point cloud
    data may be organized 2d (image-like) or 1d/ (unordered). Point clouds
    organized as 2d images may be produced by/ camera depth sensors such as
    stereo or time-of-flight.
    """

    # / \brief Optional header data. This should contain time of sensor data/
    # acquisition, and the coordinate frame ID (for 3D points).
    header: "Header" = betterproto.message_field(1)
    # / \brief Information that describes the data contained in the `data` field.
    field: List["PointCloudPackedField"] = betterproto.message_field(2)
    # / \brief Height of a 2D structured point cloud, or 1 if the point cloud is/
    # unordered.
    height: int = betterproto.uint32_field(3)
    # / \brief Width of a 2D structured point cloud, or length of the point
    # cloud/ if the point cloud is unordered.
    width: int = betterproto.uint32_field(4)
    # / \brief Is this data big endian?
    is_bigendian: bool = betterproto.bool_field(5)
    # / \brief Length of a point in bytes.
    point_step: int = betterproto.uint32_field(6)
    # / \brief Length of row in bytes.
    row_step: int = betterproto.uint32_field(7)
    # / \brief The point data, size is (row_step * height);
    data: bytes = betterproto.bytes_field(8)
    # / \brief True if there are not invalid points.
    is_dense: bool = betterproto.bool_field(9)


@dataclass
class PointCloudPackedField(betterproto.Message):
    """/ \brief A field that describes the format of the data field."""

    # / \brief Name of the field.
    name: str = betterproto.string_field(1)
    # / \brief Offset from start of point struct
    offset: int = betterproto.uint32_field(2)
    # / \brief Datatype enumeration
    datatype: "PointCloudPackedFieldDataType" = betterproto.enum_field(3)
    # / \brief How many elements in the field
    count: int = betterproto.uint32_field(4)


@dataclass
class PoseAnimation(betterproto.Message):
    model_name: str = betterproto.string_field(1)
    model_id: int = betterproto.uint32_field(2)
    pose: List["Pose"] = betterproto.message_field(3)
    time: List["Time"] = betterproto.message_field(4)


@dataclass
class PoseTrajectory(betterproto.Message):
    name: str = betterproto.string_field(1)
    id: int = betterproto.uint32_field(2)
    pose: List["Pose"] = betterproto.message_field(3)


@dataclass
class PropagationParticle(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    x: float = betterproto.double_field(2)
    y: float = betterproto.double_field(3)
    signal_level: float = betterproto.double_field(4)


@dataclass
class PropagationGrid(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    particle: List["PropagationParticle"] = betterproto.message_field(2)


@dataclass
class Publish(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    topic: str = betterproto.string_field(2)
    msg_type: str = betterproto.string_field(3)
    host: str = betterproto.string_field(4)
    port: int = betterproto.uint32_field(5)


@dataclass
class Publishers(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    publisher: List["Publish"] = betterproto.message_field(2)


@dataclass
class RaySensor(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    display_scan: bool = betterproto.bool_field(2)
    horizontal_samples: int = betterproto.int32_field(3)
    horizontal_resolution: float = betterproto.double_field(4)
    horizontal_min_angle: float = betterproto.double_field(5)
    horizontal_max_angle: float = betterproto.double_field(6)
    vertical_samples: int = betterproto.int32_field(7)
    vertical_resolution: float = betterproto.double_field(8)
    vertical_min_angle: float = betterproto.double_field(9)
    vertical_max_angle: float = betterproto.double_field(10)
    range_min: float = betterproto.double_field(11)
    range_max: float = betterproto.double_field(12)
    range_resolution: float = betterproto.double_field(13)


@dataclass
class Request(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    id: int = betterproto.int32_field(2)
    request: str = betterproto.string_field(3)
    data: str = betterproto.string_field(4)
    dbl_data: float = betterproto.double_field(5)


@dataclass
class Response(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    id: int = betterproto.int32_field(2)
    request: str = betterproto.string_field(3)
    response: str = betterproto.string_field(4)
    type: str = betterproto.string_field(5)
    serialized_data: bytes = betterproto.bytes_field(6)


@dataclass
class RestLogin(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief ID of this request message
    id: int = betterproto.uint32_field(2)
    # / \brief Rest service URL
    url: str = betterproto.string_field(3)
    # / \brief Login user name
    username: str = betterproto.string_field(4)
    # / \brief Login password
    password: str = betterproto.string_field(5)


@dataclass
class RestLogout(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief ID of this request message
    id: int = betterproto.uint32_field(2)
    # / \brief the web service url
    url: str = betterproto.string_field(3)


@dataclass
class RestPost(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief ID of this request message
    id: int = betterproto.uint32_field(2)
    # / \brief Route to post to.
    route: str = betterproto.string_field(3)
    # / \brief Data to post in JSON format
    json: str = betterproto.string_field(4)


@dataclass
class RestResponse(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief ID of the response message
    id: int = betterproto.uint32_field(2)
    # / \brief Type of response
    type: "RestResponseType" = betterproto.enum_field(3)
    # / \brief Message describing the response
    msg: str = betterproto.string_field(4)


@dataclass
class Road(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    name: str = betterproto.string_field(2)
    width: float = betterproto.double_field(3)
    point: List["Vector3d"] = betterproto.message_field(4)
    material: "Material" = betterproto.message_field(5)


@dataclass
class Sky(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    time: float = betterproto.double_field(2)
    sunrise: float = betterproto.double_field(3)
    sunset: float = betterproto.double_field(4)
    wind_speed: float = betterproto.double_field(5)
    wind_direction: float = betterproto.double_field(6)
    cloud_ambient: "Color" = betterproto.message_field(7)
    humidity: float = betterproto.double_field(8)
    mean_cloud_size: float = betterproto.double_field(9)


@dataclass
class Scene(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    name: str = betterproto.string_field(2)
    ambient: "Color" = betterproto.message_field(3)
    background: "Color" = betterproto.message_field(4)
    sky: "Sky" = betterproto.message_field(5)
    shadows: bool = betterproto.bool_field(6)
    fog: "Fog" = betterproto.message_field(7)
    grid: bool = betterproto.bool_field(8)
    model: List["Model"] = betterproto.message_field(9)
    light: List["Light"] = betterproto.message_field(10)
    joint: List["Joint"] = betterproto.message_field(11)
    # / \brief Show/hide world origin indicator.
    origin_visual: bool = betterproto.bool_field(12)


@dataclass
class SdfGeneratorConfig(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Global setting for SDFormat generation of entities
    global_entity_gen_config: "SdfGeneratorConfigEntityGeneratorConfig" = (
        betterproto.message_field(2)
    )
    # / \brief Per-entity override of global settings for SDFormat generation./
    # The key is the scoped name of an entity.
    override_entity_gen_configs: Dict[
        str, "SdfGeneratorConfigEntityGeneratorConfig"
    ] = betterproto.map_field(3, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE)


@dataclass
class SdfGeneratorConfigEntityGeneratorConfig(betterproto.Message):
    """
    / \brief Configuration for SDFormat generation of entities (eg. models,
    actors, lights)
    """

    # / \brief Expand and inline included entities
    expand_include_tags: "Boolean" = betterproto.message_field(1)
    # / \brief Use the Fuel version in generated URIs of Fuel resources
    save_fuel_version: "Boolean" = betterproto.message_field(2)
    # / \brief Use absolute paths for resources such as meshes
    resources_use_absolute_paths: "Boolean" = betterproto.message_field(3)
    # / \brief Copy model resources, such as meshes, and create a self contained/
    # model.
    copy_model_resources: "Boolean" = betterproto.message_field(4)


@dataclass
class Selection(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    id: int = betterproto.uint32_field(2)
    name: str = betterproto.string_field(3)
    selected: bool = betterproto.bool_field(4)


@dataclass
class Sensor_V(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Sensor messages.
    sensors: List["Sensor"] = betterproto.message_field(2)


@dataclass
class SerializedComponent(betterproto.Message):
    """
    / \brief Holds all the information needed to reconstruct a component.
    """

    # / \brief Unique ID that represents a component's type.
    type: int = betterproto.uint64_field(1)
    # / \brief Component's serialized data.
    component: bytes = betterproto.bytes_field(2)
    # / \brief Whether the component should be removed at the current state.
    remove: bool = betterproto.bool_field(3)


@dataclass
class SerializedEntity(betterproto.Message):
    """
    / \brief Holds all the information needed to reconstruct an entity and its/
    components.
    """

    # / \brief The entity is uniquely identified by its ID.
    id: int = betterproto.uint64_field(1)
    # / \brief All the components belonging to the entity.
    components: List["SerializedComponent"] = betterproto.message_field(2)
    # / \brief Whether the entity and all its components should be removed at
    # the/ current state.
    remove: bool = betterproto.bool_field(3)


@dataclass
class SerializedState(betterproto.Message):
    """
    / \brief Holds all the information needed to reconstruct the state of an/
    entity-component-system (ECS) architecture at a given time./ An ECS's state
    consists of several entities, each with an arbitrary number/ of components
    tied to them.
    """

    # / \brief Header data, which contains the simulation time.
    header: "Header" = betterproto.message_field(1)
    # / \brief All the entities currently in the simulation.
    entities: List["SerializedEntity"] = betterproto.message_field(2)


@dataclass
class SerializedStep(betterproto.Message):
    """
    / \brief All the data needed to step an ECS system, such as current/
    simulation time and entity states.
    """

    # / \brief Iteration information, such as sim time and paused state.
    stats: "WorldStatistics" = betterproto.message_field(1)
    # / \brief State of entities and components.
    state: "SerializedState" = betterproto.message_field(2)


@dataclass
class SerializedEntityMap(betterproto.Message):
    """
    / \brief Holds all the information needed to reconstruct an entity and its/
    components.
    """

    # / \brief The entity is uniquely identified by its ID.
    id: int = betterproto.uint64_field(1)
    # / \brief All the components belonging to the entity.
    components: Dict[int, "SerializedComponent"] = betterproto.map_field(
        2, betterproto.TYPE_INT64, betterproto.TYPE_MESSAGE
    )
    # / \brief Whether the entity and all its components should be removed at
    # the/ current state.
    remove: bool = betterproto.bool_field(3)


@dataclass
class SerializedStateMap(betterproto.Message):
    """
    / \brief Holds all the information needed to reconstruct the state of an/
    entity-component-system (ECS) architecture at a given time./ An ECS's state
    consists of several entities, each with an arbitrary number/ of components
    tied to them.
    """

    # / \brief Header data, which contains the simulation time.
    header: "Header" = betterproto.message_field(1)
    # / \brief All the entities currently in the simulation.
    entities: Dict[int, "SerializedEntityMap"] = betterproto.map_field(
        2, betterproto.TYPE_UINT64, betterproto.TYPE_MESSAGE
    )


@dataclass
class SerializedStepMap(betterproto.Message):
    """
    / \brief All the data needed to step an ECS system, such as current/
    simulation time and entity states.
    """

    # / \brief Iteration information, such as sim time and paused state.
    stats: "WorldStatistics" = betterproto.message_field(1)
    # / \brief State of entities and components.
    state: "SerializedStateMap" = betterproto.message_field(2)


@dataclass
class ServerControl(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    save_world_name: str = betterproto.string_field(2)
    save_filename: str = betterproto.string_field(3)
    open_filename: str = betterproto.string_field(4)
    new_world: bool = betterproto.bool_field(5)
    stop: bool = betterproto.bool_field(6)
    clone: bool = betterproto.bool_field(7)
    new_port: int = betterproto.uint32_field(8)


@dataclass
class Shadows(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    type: "ShadowsShadowType" = betterproto.enum_field(2)
    color: "Color" = betterproto.message_field(3)


@dataclass
class SimEvent(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief ID of this event message
    id: int = betterproto.uint32_field(2)
    # / \brief Type of sim event
    type: str = betterproto.string_field(3)
    # / \brief Name of sim event
    name: str = betterproto.string_field(4)
    # / \brief Statistics of the world
    world_statistics: "WorldStatistics" = betterproto.message_field(5)
    # / \brief Data describing the sim event
    data: str = betterproto.string_field(6)


@dataclass
class Sonar(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    frame: str = betterproto.string_field(2)
    world_pose: "Pose" = betterproto.message_field(3)
    range_min: float = betterproto.double_field(4)
    range_max: float = betterproto.double_field(5)
    radius: float = betterproto.double_field(6)
    range: float = betterproto.double_field(7)
    # / \brief The sonar collision shape./        possible values are "cone",
    # "sphere"./        If you set this value to "cone" you need to specify/
    # the `radius`.
    geometry: str = betterproto.string_field(8)
    # / Location of the contact in the world frame.
    contact: "Vector3d" = betterproto.message_field(9)


@dataclass
class SphericalCoordinates(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    surface_model: "SphericalCoordinatesSurfaceModel" = betterproto.enum_field(2)
    latitude_deg: float = betterproto.double_field(3)
    longitude_deg: float = betterproto.double_field(4)
    elevation: float = betterproto.double_field(5)
    heading_deg: float = betterproto.double_field(6)


@dataclass
class Statistic(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief The data type.
    type: "StatisticDataType" = betterproto.enum_field(2)
    # / \brief Name associated with the statistic.
    name: str = betterproto.string_field(3)
    # / \brief The statistic's value.
    value: float = betterproto.double_field(4)


@dataclass
class StatisticsGroup(betterproto.Message):
    """/ \brief A named group of statistics."""

    # / \brief Optional header data.
    header: "Header" = betterproto.message_field(1)
    # / \brief Name of the group.
    name: str = betterproto.string_field(2)
    # / \brief Statistics the belong to this group.
    statistics: List["Statistic"] = betterproto.message_field(3)


@dataclass
class Metric(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Unit of measurement such as seconds, meters, liters.
    unit: str = betterproto.string_field(2)
    # / \brief Zero or more named groups of statistics. A statistic group is/
    # used to bundle data into a logical set with an associated name.
    statistics_groups: List["StatisticsGroup"] = betterproto.message_field(3)
    # / \brief Zero or more statistics.
    statistics: List["Statistic"] = betterproto.message_field(4)


@dataclass
class Subscribe(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    topic: str = betterproto.string_field(2)
    host: str = betterproto.string_field(3)
    port: int = betterproto.uint32_field(4)
    msg_type: str = betterproto.string_field(5)
    latching: bool = betterproto.bool_field(6)


@dataclass
class Tactile(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    collision_name: List[str] = betterproto.string_field(2)
    collision_id: List[int] = betterproto.uint32_field(3)
    pressure: List[float] = betterproto.double_field(4)


@dataclass
class Test(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)


@dataclass
class TopicInfo(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    msg_type: str = betterproto.string_field(2)
    publisher: List["Publish"] = betterproto.message_field(3)
    subscriber: List["Subscribe"] = betterproto.message_field(4)


@dataclass
class UInt32(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Integer data
    data: int = betterproto.uint32_field(2)


@dataclass
class UInt32_V(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Vector of int data
    data: List[int] = betterproto.uint32_field(2)


@dataclass
class UInt64(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Integer data
    data: int = betterproto.uint64_field(2)


@dataclass
class UInt64_V(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Vector of int data
    data: List[int] = betterproto.uint64_field(2)


@dataclass
class UndoRedo(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief True to undo, false to redo.
    undo: bool = betterproto.bool_field(2)
    # / \brief Unique id of the user command. If this is provided, all commands/
    # leading to that will be undone / redone.
    id: int = betterproto.uint32_field(3)


@dataclass
class WorldReset(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    all: bool = betterproto.bool_field(2)
    time_only: bool = betterproto.bool_field(3)
    model_only: bool = betterproto.bool_field(4)


@dataclass
class WorldControl(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    pause: bool = betterproto.bool_field(2)
    step: bool = betterproto.bool_field(3)
    multi_step: int = betterproto.uint32_field(4)
    reset: "WorldReset" = betterproto.message_field(5)
    seed: int = betterproto.uint32_field(6)


@dataclass
class UserCmd(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Unique id for user command.
    id: int = betterproto.uint32_field(2)
    # / \brief Description for the command.
    description: str = betterproto.string_field(3)
    # / \brief Type of command.
    type: "UserCmdType" = betterproto.enum_field(4)
    # / \brief For model modify commands.
    model: List["Model"] = betterproto.message_field(5)
    # / \brief For light modify commands.
    light: List["Light"] = betterproto.message_field(6)
    # / \brief Name of entity targeted by command
    entity_name: str = betterproto.string_field(7)
    # / \brief For World Control commands.
    world_control: "WorldControl" = betterproto.message_field(8)
    # / \brief Wrench for apply wrench commands.
    wrench: "Wrench" = betterproto.message_field(9)


@dataclass
class UserCmdStats(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief User commands in the undo list.
    undo_cmd: List["UserCmd"] = betterproto.message_field(2)
    # / \brief User commands in the redo list.
    redo_cmd: List["UserCmd"] = betterproto.message_field(3)


@dataclass
class VideoRecord(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief True to start video recording
    start: bool = betterproto.bool_field(2)
    # / \brief True to stop video recording
    stop: bool = betterproto.bool_field(3)
    # / \brief Video encoding format, e.g. "mp4", "ogv"
    format: str = betterproto.string_field(4)
    # / \brief filename of the recorded video
    save_filename: str = betterproto.string_field(5)


@dataclass
class Visual_V(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    # / \brief Visual messages.
    visuals: List["Visual"] = betterproto.message_field(2)


@dataclass
class Wind(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    linear_velocity: "Vector3d" = betterproto.message_field(2)
    enable_wind: bool = betterproto.bool_field(3)


@dataclass
class WirelessNode(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    essid: str = betterproto.string_field(2)
    frequency: float = betterproto.double_field(3)
    signal_level: float = betterproto.double_field(4)


@dataclass
class WirelessNodes(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    node: List["WirelessNode"] = betterproto.message_field(2)


@dataclass
class WorldModify(betterproto.Message):
    # / \brief Optional header data
    header: "Header" = betterproto.message_field(1)
    world_name: str = betterproto.string_field(2)
    remove: bool = betterproto.bool_field(3)
    create: bool = betterproto.bool_field(4)
    cloned: bool = betterproto.bool_field(5)
    cloned_uri: str = betterproto.string_field(6)
